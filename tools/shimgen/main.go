package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

const (
	modulePath   = "github.com/merlindrones/rclgo" // module root
	publicRoot   = "pkg/msgs"                      // public msgs live here
	internalRoot = "internal/msgs"                 // shims will be written here
)

func main() {
	err := filepath.Walk(publicRoot, func(path string, info os.FileInfo, walkErr error) error {
		if walkErr != nil {
			return walkErr
		}
		if !info.IsDir() {
			return nil
		}
		base := filepath.Base(path)
		if base != "msg" && base != "srv" && base != "action" {
			return nil
		}

		rel, _ := filepath.Rel(publicRoot, path) // e.g. "std_msgs/msg"
		rosPkg := filepath.Dir(rel)              // e.g. "std_msgs"
		subpkg := filepath.Base(path)            // "msg"|"srv"|"action"

		publicImport := fmt.Sprintf("%s/%s/%s", modulePath, publicRoot, rel)
		internalDir := filepath.Join(internalRoot, rosPkg, subpkg)
		if err := os.MkdirAll(internalDir, 0o755); err != nil {
			return err
		}
		outfile := filepath.Join(internalDir, "shim.go")

		// Collect exported identifiers from package source files.
		typeNames := map[string]struct{}{}
		constNames := map[string]struct{}{}
		varNames := map[string]struct{}{}
		funcNames := map[string]struct{}{}

		fset := token.NewFileSet()
		entries, err := os.ReadDir(path)
		if err != nil {
			return err
		}
		for _, ent := range entries {
			// Only parse .go files (skip tests)
			if ent.IsDir() || !strings.HasSuffix(ent.Name(), ".go") || strings.HasSuffix(ent.Name(), "_test.go") {
				continue
			}
			fp := filepath.Join(path, ent.Name())
			f, err := parser.ParseFile(fset, fp, nil, parser.SkipObjectResolution)
			if err != nil {
				return fmt.Errorf("parse %s: %w", fp, err)
			}

			for _, decl := range f.Decls {
				switch d := decl.(type) {
				case *ast.GenDecl:
					switch d.Tok {
					case token.TYPE:
						for _, spec := range d.Specs {
							if ts, ok := spec.(*ast.TypeSpec); ok && ts.Name != nil && ts.Name.IsExported() {
								typeNames[ts.Name.Name] = struct{}{}
							}
						}
					case token.CONST:
						for _, spec := range d.Specs {
							if vs, ok := spec.(*ast.ValueSpec); ok {
								for _, name := range vs.Names {
									if name.IsExported() {
										constNames[name.Name] = struct{}{}
									}
								}
							}
						}
					case token.VAR:
						for _, spec := range d.Specs {
							if vs, ok := spec.(*ast.ValueSpec); ok {
								for _, name := range vs.Names {
									if name.IsExported() {
										varNames[name.Name] = struct{}{}
									}
								}
							}
						}
					}
				case *ast.FuncDecl:
					// Only top-level funcs (no receiver) and exported
					if d.Recv == nil && d.Name != nil && d.Name.IsExported() && d.Name.Name != "Init" && d.Name.Name != "init" {
						funcNames[d.Name.Name] = struct{}{}
					}
				}
			}
		}

		// Deterministic ordering
		typeList := keys(typeNames)
		constList := keys(constNames)
		varList := keys(varNames)
		funcList := keys(funcNames)
		sort.Strings(typeList)
		sort.Strings(constList)
		sort.Strings(varList)
		sort.Strings(funcList)

		f, err := os.Create(outfile)
		if err != nil {
			return err
		}
		defer f.Close()

		fmt.Fprintf(f, "// Code generated by shimgen; DO NOT EDIT.\n")
		fmt.Fprintf(f, "// Deprecated: use %s instead.\n", publicImport)
		fmt.Fprintf(f, "package %s\n\n", subpkg)

		// If no exports found, emit a blank import so old imports keep compiling.
		if len(typeList)+len(constList)+len(varList)+len(funcList) == 0 {
			fmt.Fprintf(f, "import _ \"%s\"\n", publicImport)
			fmt.Fprintln(f)
			fmt.Fprintln(f, "// (no exported identifiers to alias)")
			fmt.Printf("wrote shim (blank import): %s -> %s\n", path, outfile)
			return nil
		}

		// Otherwise, alias everything we found.
		fmt.Fprintf(f, "import pub \"%s\"\n\n", publicImport)

		for _, n := range typeList {
			fmt.Fprintf(f, "type %s = pub.%s\n", n, n)
		}
		if len(typeList) > 0 && (len(constList)+len(varList)+len(funcList) > 0) {
			fmt.Fprintln(f)
		}
		for _, n := range constList {
			fmt.Fprintf(f, "const %s = pub.%s\n", n, n)
		}
		if len(constList) > 0 && (len(varList)+len(funcList) > 0) {
			fmt.Fprintln(f)
		}
		for _, n := range varList {
			fmt.Fprintf(f, "var %s = pub.%s\n", n, n)
		}
		if len(varList) > 0 && len(funcList) > 0 {
			fmt.Fprintln(f)
		}
		for _, n := range funcList {
			fmt.Fprintf(f, "var %s = pub.%s\n", n, n)
		}

		fmt.Printf("wrote shim: %s -> %s\n", path, outfile)
		return nil
	})
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func keys(m map[string]struct{}) []string {
	out := make([]string, 0, len(m))
	for k := range m {
		out = append(out, k)
	}
	return out
}
