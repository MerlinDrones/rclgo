// Code generated by rclgo-gen. DO NOT EDIT.

package px4_msgs_msg

import (
	"unsafe"

	"github.com/merlindrones/rclgo/pkg/rclgo"
	primitives "github.com/merlindrones/rclgo/pkg/rclgo/primitives"
	"github.com/merlindrones/rclgo/pkg/rclgo/typemap"
	"github.com/merlindrones/rclgo/pkg/rclgo/types"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/battery_status.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/BatteryStatus", BatteryStatusTypeSupport)
	typemap.RegisterMessage("px4_msgs/msg/BatteryStatus", BatteryStatusTypeSupport)
}

const (
	BatteryStatus_BATTERY_SOURCE_POWER_MODULE         uint8 = 0
	BatteryStatus_BATTERY_SOURCE_EXTERNAL             uint8 = 1
	BatteryStatus_BATTERY_SOURCE_ESCS                 uint8 = 2
	BatteryStatus_BATTERY_WARNING_NONE                uint8 = 0  // no battery low voltage warning active
	BatteryStatus_BATTERY_WARNING_LOW                 uint8 = 1  // warning of low voltage
	BatteryStatus_BATTERY_WARNING_CRITICAL            uint8 = 2  // critical voltage, return / abort immediately
	BatteryStatus_BATTERY_WARNING_EMERGENCY           uint8 = 3  // immediate landing required
	BatteryStatus_BATTERY_WARNING_FAILED              uint8 = 4  // the battery has failed completely
	BatteryStatus_BATTERY_STATE_UNHEALTHY             uint8 = 6  // Battery is diagnosed to be defective or an error occurred, usage is discouraged / prohibited. Possible causes (faults) are listed in faults field.
	BatteryStatus_BATTERY_STATE_CHARGING              uint8 = 7  // Battery is charging
	BatteryStatus_BATTERY_FAULT_DEEP_DISCHARGE        uint8 = 0  // Battery has deep discharged
	BatteryStatus_BATTERY_FAULT_SPIKES                uint8 = 1  // Voltage spikes
	BatteryStatus_BATTERY_FAULT_CELL_FAIL             uint8 = 2  // One or more cells have failed
	BatteryStatus_BATTERY_FAULT_OVER_CURRENT          uint8 = 3  // Over-current
	BatteryStatus_BATTERY_FAULT_OVER_TEMPERATURE      uint8 = 4  // Over-temperature
	BatteryStatus_BATTERY_FAULT_UNDER_TEMPERATURE     uint8 = 5  // Under-temperature fault
	BatteryStatus_BATTERY_FAULT_INCOMPATIBLE_VOLTAGE  uint8 = 6  // Vehicle voltage is not compatible with this battery (batteries on same power rail should have similar voltage).
	BatteryStatus_BATTERY_FAULT_INCOMPATIBLE_FIRMWARE uint8 = 7  // Battery firmware is not compatible with current autopilot firmware
	BatteryStatus_BATTERY_FAULT_INCOMPATIBLE_MODEL    uint8 = 8  // Battery model is not supported by the system
	BatteryStatus_BATTERY_FAULT_HARDWARE_FAILURE      uint8 = 9  // hardware problem
	BatteryStatus_BATTERY_FAULT_FAILED_TO_ARM         uint8 = 10 // Battery had a problem while arming
	BatteryStatus_BATTERY_FAULT_COUNT                 uint8 = 11 // Counter - keep it as last element!
	BatteryStatus_MAX_INSTANCES                       uint8 = 4
)

type BatteryStatus struct {
	Timestamp                  uint64      `yaml:"timestamp"`                    // time since system start (microseconds)
	Connected                  bool        `yaml:"connected"`                    // Whether or not a battery is connected, based on a voltage threshold
	VoltageV                   float32     `yaml:"voltage_v"`                    // Battery voltage in volts, 0 if unknown
	CurrentA                   float32     `yaml:"current_a"`                    // Battery current in amperes, -1 if unknown
	CurrentAverageA            float32     `yaml:"current_average_a"`            // Battery current average in amperes (for FW average in level flight), -1 if unknown
	DischargedMah              float32     `yaml:"discharged_mah"`               // Discharged amount in mAh, -1 if unknown
	Remaining                  float32     `yaml:"remaining"`                    // From 1 to 0, -1 if unknown
	Scale                      float32     `yaml:"scale"`                        // Power scaling factor, >= 1, or -1 if unknown
	TimeRemainingS             float32     `yaml:"time_remaining_s"`             // predicted time in seconds remaining until battery is empty under previous averaged load, NAN if unknown
	Temperature                float32     `yaml:"temperature"`                  // Temperature of the battery in degrees Celcius, NaN if unknown
	CellCount                  uint8       `yaml:"cell_count"`                   // Number of cells, 0 if unknown
	Source                     uint8       `yaml:"source"`                       // Battery source
	Priority                   uint8       `yaml:"priority"`                     // Zero based priority is the connection on the Power Controller V1..Vn AKA BrickN-1
	Capacity                   uint16      `yaml:"capacity"`                     // actual capacity of the battery
	CycleCount                 uint16      `yaml:"cycle_count"`                  // number of discharge cycles the battery has experienced
	AverageTimeToEmpty         uint16      `yaml:"average_time_to_empty"`        // predicted remaining battery capacity based on the average rate of discharge in min
	SerialNumber               uint16      `yaml:"serial_number"`                // serial number of the battery pack
	ManufactureDate            uint16      `yaml:"manufacture_date"`             // manufacture date, part of serial number of the battery pack. Formatted as: Day + Month×32 + (Year–1980)×512
	StateOfHealth              uint16      `yaml:"state_of_health"`              // state of health. FullChargeCapacity/DesignCapacity, 0-100%.
	MaxError                   uint16      `yaml:"max_error"`                    // max error, expected margin of error in % in the state-of-charge calculation with a range of 1 to 100%
	Id                         uint8       `yaml:"id"`                           // ID number of a battery. Should be unique and consistent for the lifetime of a vehicle. 1-indexed.
	InterfaceError             uint16      `yaml:"interface_error"`              // interface error counter
	VoltageCellV               [14]float32 `yaml:"voltage_cell_v"`               // Battery individual cell voltages, 0 if unknown
	MaxCellVoltageDelta        float32     `yaml:"max_cell_voltage_delta"`       // Max difference between individual cell voltages
	IsPoweringOff              bool        `yaml:"is_powering_off"`              // Power off event imminent indication, false if unknown
	IsRequired                 bool        `yaml:"is_required"`                  // Set if the battery is explicitly required before arming
	Faults                     uint16      `yaml:"faults"`                       // Smart battery supply status/fault flags (bitmask) for health indication.
	Warning                    uint8       `yaml:"warning"`                      // Current battery warning
	FullChargeCapacityWh       float32     `yaml:"full_charge_capacity_wh"`      // The compensated battery capacity
	RemainingCapacityWh        float32     `yaml:"remaining_capacity_wh"`        // The compensated battery capacity remaining
	OverDischargeCount         uint16      `yaml:"over_discharge_count"`         // Number of battery overdischarge
	NominalVoltage             float32     `yaml:"nominal_voltage"`              // Nominal voltage of the battery pack
	InternalResistanceEstimate float32     `yaml:"internal_resistance_estimate"` // [Ohm] Internal resistance per cell estimate
	OcvEstimate                float32     `yaml:"ocv_estimate"`                 // [V] Open circuit voltage estimate
	OcvEstimateFiltered        float32     `yaml:"ocv_estimate_filtered"`        // [V] Filtered open circuit voltage estimate
	VoltBasedSocEstimate       float32     `yaml:"volt_based_soc_estimate"`      // [0, 1] Normalized volt based state of charge estimate
	VoltagePrediction          float32     `yaml:"voltage_prediction"`           // [V] Predicted voltage
	PredictionError            float32     `yaml:"prediction_error"`             // [V] Prediction error
	EstimationCovarianceNorm   float32     `yaml:"estimation_covariance_norm"`   // Norm of the covariance matrix
}

// NewBatteryStatus creates a new BatteryStatus with default values.
func NewBatteryStatus() *BatteryStatus {
	self := BatteryStatus{}
	self.SetDefaults()
	return &self
}

func (t *BatteryStatus) Clone() *BatteryStatus {
	c := &BatteryStatus{}
	c.Timestamp = t.Timestamp
	c.Connected = t.Connected
	c.VoltageV = t.VoltageV
	c.CurrentA = t.CurrentA
	c.CurrentAverageA = t.CurrentAverageA
	c.DischargedMah = t.DischargedMah
	c.Remaining = t.Remaining
	c.Scale = t.Scale
	c.TimeRemainingS = t.TimeRemainingS
	c.Temperature = t.Temperature
	c.CellCount = t.CellCount
	c.Source = t.Source
	c.Priority = t.Priority
	c.Capacity = t.Capacity
	c.CycleCount = t.CycleCount
	c.AverageTimeToEmpty = t.AverageTimeToEmpty
	c.SerialNumber = t.SerialNumber
	c.ManufactureDate = t.ManufactureDate
	c.StateOfHealth = t.StateOfHealth
	c.MaxError = t.MaxError
	c.Id = t.Id
	c.InterfaceError = t.InterfaceError
	c.VoltageCellV = t.VoltageCellV
	c.MaxCellVoltageDelta = t.MaxCellVoltageDelta
	c.IsPoweringOff = t.IsPoweringOff
	c.IsRequired = t.IsRequired
	c.Faults = t.Faults
	c.Warning = t.Warning
	c.FullChargeCapacityWh = t.FullChargeCapacityWh
	c.RemainingCapacityWh = t.RemainingCapacityWh
	c.OverDischargeCount = t.OverDischargeCount
	c.NominalVoltage = t.NominalVoltage
	c.InternalResistanceEstimate = t.InternalResistanceEstimate
	c.OcvEstimate = t.OcvEstimate
	c.OcvEstimateFiltered = t.OcvEstimateFiltered
	c.VoltBasedSocEstimate = t.VoltBasedSocEstimate
	c.VoltagePrediction = t.VoltagePrediction
	c.PredictionError = t.PredictionError
	c.EstimationCovarianceNorm = t.EstimationCovarianceNorm
	return c
}

func (t *BatteryStatus) CloneMsg() types.Message {
	return t.Clone()
}

func (t *BatteryStatus) SetDefaults() {
	t.Timestamp = 0
	t.Connected = false
	t.VoltageV = 0
	t.CurrentA = 0
	t.CurrentAverageA = 0
	t.DischargedMah = 0
	t.Remaining = 0
	t.Scale = 0
	t.TimeRemainingS = 0
	t.Temperature = 0
	t.CellCount = 0
	t.Source = 0
	t.Priority = 0
	t.Capacity = 0
	t.CycleCount = 0
	t.AverageTimeToEmpty = 0
	t.SerialNumber = 0
	t.ManufactureDate = 0
	t.StateOfHealth = 0
	t.MaxError = 0
	t.Id = 0
	t.InterfaceError = 0
	t.VoltageCellV = [14]float32{}
	t.MaxCellVoltageDelta = 0
	t.IsPoweringOff = false
	t.IsRequired = false
	t.Faults = 0
	t.Warning = 0
	t.FullChargeCapacityWh = 0
	t.RemainingCapacityWh = 0
	t.OverDischargeCount = 0
	t.NominalVoltage = 0
	t.InternalResistanceEstimate = 0
	t.OcvEstimate = 0
	t.OcvEstimateFiltered = 0
	t.VoltBasedSocEstimate = 0
	t.VoltagePrediction = 0
	t.PredictionError = 0
	t.EstimationCovarianceNorm = 0
}

func (t *BatteryStatus) GetTypeSupport() types.MessageTypeSupport {
	return BatteryStatusTypeSupport
}

// BatteryStatusPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type BatteryStatusPublisher struct {
	*rclgo.Publisher
}

// NewBatteryStatusPublisher creates and returns a new publisher for the
// BatteryStatus
func NewBatteryStatusPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*BatteryStatusPublisher, error) {
	pub, err := node.NewPublisher(topic_name, BatteryStatusTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &BatteryStatusPublisher{pub}, nil
}

func (p *BatteryStatusPublisher) Publish(msg *BatteryStatus) error {
	return p.Publisher.Publish(msg)
}

// BatteryStatusSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type BatteryStatusSubscription struct {
	*rclgo.Subscription
}

// BatteryStatusSubscriptionCallback type is used to provide a subscription
// handler function for a BatteryStatusSubscription.
type BatteryStatusSubscriptionCallback func(msg *BatteryStatus, info *rclgo.MessageInfo, err error)

// NewBatteryStatusSubscription creates and returns a new subscription for the
// BatteryStatus
func NewBatteryStatusSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback BatteryStatusSubscriptionCallback) (*BatteryStatusSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg BatteryStatus
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, BatteryStatusTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &BatteryStatusSubscription{sub}, nil
}

func (s *BatteryStatusSubscription) TakeMessage(out *BatteryStatus) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneBatteryStatusSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneBatteryStatusSlice(dst, src []BatteryStatus) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var BatteryStatusTypeSupport types.MessageTypeSupport = _BatteryStatusTypeSupport{}

type _BatteryStatusTypeSupport struct{}

func (t _BatteryStatusTypeSupport) New() types.Message {
	return NewBatteryStatus()
}

func (t _BatteryStatusTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__BatteryStatus
	return (unsafe.Pointer)(C.px4_msgs__msg__BatteryStatus__create())
}

func (t _BatteryStatusTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__BatteryStatus__destroy((*C.px4_msgs__msg__BatteryStatus)(pointer_to_free))
}

func (t _BatteryStatusTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*BatteryStatus)
	mem := (*C.px4_msgs__msg__BatteryStatus)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.connected = C.bool(m.Connected)
	mem.voltage_v = C.float(m.VoltageV)
	mem.current_a = C.float(m.CurrentA)
	mem.current_average_a = C.float(m.CurrentAverageA)
	mem.discharged_mah = C.float(m.DischargedMah)
	mem.remaining = C.float(m.Remaining)
	mem.scale = C.float(m.Scale)
	mem.time_remaining_s = C.float(m.TimeRemainingS)
	mem.temperature = C.float(m.Temperature)
	mem.cell_count = C.uint8_t(m.CellCount)
	mem.source = C.uint8_t(m.Source)
	mem.priority = C.uint8_t(m.Priority)
	mem.capacity = C.uint16_t(m.Capacity)
	mem.cycle_count = C.uint16_t(m.CycleCount)
	mem.average_time_to_empty = C.uint16_t(m.AverageTimeToEmpty)
	mem.serial_number = C.uint16_t(m.SerialNumber)
	mem.manufacture_date = C.uint16_t(m.ManufactureDate)
	mem.state_of_health = C.uint16_t(m.StateOfHealth)
	mem.max_error = C.uint16_t(m.MaxError)
	mem.id = C.uint8_t(m.Id)
	mem.interface_error = C.uint16_t(m.InterfaceError)
	cSlice_voltage_cell_v := mem.voltage_cell_v[:]
	primitives.Float32__Array_to_C(*(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_voltage_cell_v)), m.VoltageCellV[:])
	mem.max_cell_voltage_delta = C.float(m.MaxCellVoltageDelta)
	mem.is_powering_off = C.bool(m.IsPoweringOff)
	mem.is_required = C.bool(m.IsRequired)
	mem.faults = C.uint16_t(m.Faults)
	mem.warning = C.uint8_t(m.Warning)
	mem.full_charge_capacity_wh = C.float(m.FullChargeCapacityWh)
	mem.remaining_capacity_wh = C.float(m.RemainingCapacityWh)
	mem.over_discharge_count = C.uint16_t(m.OverDischargeCount)
	mem.nominal_voltage = C.float(m.NominalVoltage)
	mem.internal_resistance_estimate = C.float(m.InternalResistanceEstimate)
	mem.ocv_estimate = C.float(m.OcvEstimate)
	mem.ocv_estimate_filtered = C.float(m.OcvEstimateFiltered)
	mem.volt_based_soc_estimate = C.float(m.VoltBasedSocEstimate)
	mem.voltage_prediction = C.float(m.VoltagePrediction)
	mem.prediction_error = C.float(m.PredictionError)
	mem.estimation_covariance_norm = C.float(m.EstimationCovarianceNorm)
}

func (t _BatteryStatusTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*BatteryStatus)
	mem := (*C.px4_msgs__msg__BatteryStatus)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.Connected = bool(mem.connected)
	m.VoltageV = float32(mem.voltage_v)
	m.CurrentA = float32(mem.current_a)
	m.CurrentAverageA = float32(mem.current_average_a)
	m.DischargedMah = float32(mem.discharged_mah)
	m.Remaining = float32(mem.remaining)
	m.Scale = float32(mem.scale)
	m.TimeRemainingS = float32(mem.time_remaining_s)
	m.Temperature = float32(mem.temperature)
	m.CellCount = uint8(mem.cell_count)
	m.Source = uint8(mem.source)
	m.Priority = uint8(mem.priority)
	m.Capacity = uint16(mem.capacity)
	m.CycleCount = uint16(mem.cycle_count)
	m.AverageTimeToEmpty = uint16(mem.average_time_to_empty)
	m.SerialNumber = uint16(mem.serial_number)
	m.ManufactureDate = uint16(mem.manufacture_date)
	m.StateOfHealth = uint16(mem.state_of_health)
	m.MaxError = uint16(mem.max_error)
	m.Id = uint8(mem.id)
	m.InterfaceError = uint16(mem.interface_error)
	cSlice_voltage_cell_v := mem.voltage_cell_v[:]
	primitives.Float32__Array_to_Go(m.VoltageCellV[:], *(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_voltage_cell_v)))
	m.MaxCellVoltageDelta = float32(mem.max_cell_voltage_delta)
	m.IsPoweringOff = bool(mem.is_powering_off)
	m.IsRequired = bool(mem.is_required)
	m.Faults = uint16(mem.faults)
	m.Warning = uint8(mem.warning)
	m.FullChargeCapacityWh = float32(mem.full_charge_capacity_wh)
	m.RemainingCapacityWh = float32(mem.remaining_capacity_wh)
	m.OverDischargeCount = uint16(mem.over_discharge_count)
	m.NominalVoltage = float32(mem.nominal_voltage)
	m.InternalResistanceEstimate = float32(mem.internal_resistance_estimate)
	m.OcvEstimate = float32(mem.ocv_estimate)
	m.OcvEstimateFiltered = float32(mem.ocv_estimate_filtered)
	m.VoltBasedSocEstimate = float32(mem.volt_based_soc_estimate)
	m.VoltagePrediction = float32(mem.voltage_prediction)
	m.PredictionError = float32(mem.prediction_error)
	m.EstimationCovarianceNorm = float32(mem.estimation_covariance_norm)
}

func (t _BatteryStatusTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__BatteryStatus())
}

type CBatteryStatus = C.px4_msgs__msg__BatteryStatus
type CBatteryStatus__Sequence = C.px4_msgs__msg__BatteryStatus__Sequence

func BatteryStatus__Sequence_to_Go(goSlice *[]BatteryStatus, cSlice CBatteryStatus__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]BatteryStatus, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		BatteryStatusTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func BatteryStatus__Sequence_to_C(cSlice *CBatteryStatus__Sequence, goSlice []BatteryStatus) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.px4_msgs__msg__BatteryStatus)(C.malloc(C.sizeof_struct_px4_msgs__msg__BatteryStatus * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		BatteryStatusTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func BatteryStatus__Array_to_Go(goSlice []BatteryStatus, cSlice []CBatteryStatus) {
	for i := 0; i < len(cSlice); i++ {
		BatteryStatusTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func BatteryStatus__Array_to_C(cSlice []CBatteryStatus, goSlice []BatteryStatus) {
	for i := 0; i < len(goSlice); i++ {
		BatteryStatusTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
