// Code generated by rclgo-gen. DO NOT EDIT.

package px4_msgs_msg

import (
	"unsafe"

	"github.com/merlindrones/rclgo/pkg/rclgo"
	"github.com/merlindrones/rclgo/pkg/rclgo/typemap"
	"github.com/merlindrones/rclgo/pkg/rclgo/types"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/failsafe_flags.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/FailsafeFlags", FailsafeFlagsTypeSupport)
	typemap.RegisterMessage("px4_msgs/msg/FailsafeFlags", FailsafeFlagsTypeSupport)
}

type FailsafeFlags struct {
	Timestamp                          uint64 `yaml:"timestamp"`                 // time since system start (microseconds)
	ModeReqAngularVelocity             uint32 `yaml:"mode_req_angular_velocity"` // Per-mode requirements
	ModeReqAttitude                    uint32 `yaml:"mode_req_attitude"`
	ModeReqLocalAlt                    uint32 `yaml:"mode_req_local_alt"`
	ModeReqLocalPosition               uint32 `yaml:"mode_req_local_position"`
	ModeReqLocalPositionRelaxed        uint32 `yaml:"mode_req_local_position_relaxed"`
	ModeReqGlobalPosition              uint32 `yaml:"mode_req_global_position"`
	ModeReqMission                     uint32 `yaml:"mode_req_mission"`
	ModeReqOffboardSignal              uint32 `yaml:"mode_req_offboard_signal"`
	ModeReqHomePosition                uint32 `yaml:"mode_req_home_position"`
	ModeReqWindAndFlightTimeCompliance uint32 `yaml:"mode_req_wind_and_flight_time_compliance"` // if set, mode cannot be entered if wind or flight time limit exceeded
	ModeReqPreventArming               uint32 `yaml:"mode_req_prevent_arming"`                  // if set, cannot arm while in this mode
	ModeReqManualControl               uint32 `yaml:"mode_req_manual_control"`
	ModeReqOther                       uint32 `yaml:"mode_req_other"`                 // other requirements, not covered above (for external modes)
	AngularVelocityInvalid             bool   `yaml:"angular_velocity_invalid"`       // Angular velocity invalid. Mode requirements
	AttitudeInvalid                    bool   `yaml:"attitude_invalid"`               // Attitude invalid
	LocalAltitudeInvalid               bool   `yaml:"local_altitude_invalid"`         // Local altitude invalid
	LocalPositionInvalid               bool   `yaml:"local_position_invalid"`         // Local position estimate invalid
	LocalPositionInvalidRelaxed        bool   `yaml:"local_position_invalid_relaxed"` // Local position with reduced accuracy requirements invalid (e.g. flying with optical flow)
	LocalVelocityInvalid               bool   `yaml:"local_velocity_invalid"`         // Local velocity estimate invalid
	GlobalPositionInvalid              bool   `yaml:"global_position_invalid"`        // Global position estimate invalid
	AutoMissionMissing                 bool   `yaml:"auto_mission_missing"`           // No mission available
	OffboardControlSignalLost          bool   `yaml:"offboard_control_signal_lost"`   // Offboard signal lost
	HomePositionInvalid                bool   `yaml:"home_position_invalid"`          // No home position available
	ManualControlSignalLost            bool   `yaml:"manual_control_signal_lost"`     // Manual control (RC) signal lost. Control links
	GcsConnectionLost                  bool   `yaml:"gcs_connection_lost"`            // GCS connection lost
	BatteryWarning                     uint8  `yaml:"battery_warning"`                // Battery warning level (see BatteryStatus.msg). Battery
	BatteryLowRemainingTime            bool   `yaml:"battery_low_remaining_time"`     // Low battery based on remaining flight time
	BatteryUnhealthy                   bool   `yaml:"battery_unhealthy"`              // Battery unhealthy
	GeofenceBreached                   bool   `yaml:"geofence_breached"`              // Geofence breached (one or multiple). Other
	MissionFailure                     bool   `yaml:"mission_failure"`                // Mission failure
	VtolFixedWingSystemFailure         bool   `yaml:"vtol_fixed_wing_system_failure"` // vehicle in fixed-wing system failure failsafe mode (after quad-chute)
	WindLimitExceeded                  bool   `yaml:"wind_limit_exceeded"`            // Wind limit exceeded
	FlightTimeLimitExceeded            bool   `yaml:"flight_time_limit_exceeded"`     // Maximum flight time exceeded
	LocalPositionAccuracyLow           bool   `yaml:"local_position_accuracy_low"`    // Local position estimate has dropped below threshold, but is currently still declared valid
	NavigatorFailure                   bool   `yaml:"navigator_failure"`              // Navigator failed to execute a mode
	FdCriticalFailure                  bool   `yaml:"fd_critical_failure"`            // Critical failure (attitude/altitude limit exceeded, or external ATS). Failure detector
	FdEscArmingFailure                 bool   `yaml:"fd_esc_arming_failure"`          // ESC failed to arm
	FdImbalancedProp                   bool   `yaml:"fd_imbalanced_prop"`             // Imbalanced propeller detected
	FdMotorFailure                     bool   `yaml:"fd_motor_failure"`               // Motor failure
}

// NewFailsafeFlags creates a new FailsafeFlags with default values.
func NewFailsafeFlags() *FailsafeFlags {
	self := FailsafeFlags{}
	self.SetDefaults()
	return &self
}

func (t *FailsafeFlags) Clone() *FailsafeFlags {
	c := &FailsafeFlags{}
	c.Timestamp = t.Timestamp
	c.ModeReqAngularVelocity = t.ModeReqAngularVelocity
	c.ModeReqAttitude = t.ModeReqAttitude
	c.ModeReqLocalAlt = t.ModeReqLocalAlt
	c.ModeReqLocalPosition = t.ModeReqLocalPosition
	c.ModeReqLocalPositionRelaxed = t.ModeReqLocalPositionRelaxed
	c.ModeReqGlobalPosition = t.ModeReqGlobalPosition
	c.ModeReqMission = t.ModeReqMission
	c.ModeReqOffboardSignal = t.ModeReqOffboardSignal
	c.ModeReqHomePosition = t.ModeReqHomePosition
	c.ModeReqWindAndFlightTimeCompliance = t.ModeReqWindAndFlightTimeCompliance
	c.ModeReqPreventArming = t.ModeReqPreventArming
	c.ModeReqManualControl = t.ModeReqManualControl
	c.ModeReqOther = t.ModeReqOther
	c.AngularVelocityInvalid = t.AngularVelocityInvalid
	c.AttitudeInvalid = t.AttitudeInvalid
	c.LocalAltitudeInvalid = t.LocalAltitudeInvalid
	c.LocalPositionInvalid = t.LocalPositionInvalid
	c.LocalPositionInvalidRelaxed = t.LocalPositionInvalidRelaxed
	c.LocalVelocityInvalid = t.LocalVelocityInvalid
	c.GlobalPositionInvalid = t.GlobalPositionInvalid
	c.AutoMissionMissing = t.AutoMissionMissing
	c.OffboardControlSignalLost = t.OffboardControlSignalLost
	c.HomePositionInvalid = t.HomePositionInvalid
	c.ManualControlSignalLost = t.ManualControlSignalLost
	c.GcsConnectionLost = t.GcsConnectionLost
	c.BatteryWarning = t.BatteryWarning
	c.BatteryLowRemainingTime = t.BatteryLowRemainingTime
	c.BatteryUnhealthy = t.BatteryUnhealthy
	c.GeofenceBreached = t.GeofenceBreached
	c.MissionFailure = t.MissionFailure
	c.VtolFixedWingSystemFailure = t.VtolFixedWingSystemFailure
	c.WindLimitExceeded = t.WindLimitExceeded
	c.FlightTimeLimitExceeded = t.FlightTimeLimitExceeded
	c.LocalPositionAccuracyLow = t.LocalPositionAccuracyLow
	c.NavigatorFailure = t.NavigatorFailure
	c.FdCriticalFailure = t.FdCriticalFailure
	c.FdEscArmingFailure = t.FdEscArmingFailure
	c.FdImbalancedProp = t.FdImbalancedProp
	c.FdMotorFailure = t.FdMotorFailure
	return c
}

func (t *FailsafeFlags) CloneMsg() types.Message {
	return t.Clone()
}

func (t *FailsafeFlags) SetDefaults() {
	t.Timestamp = 0
	t.ModeReqAngularVelocity = 0
	t.ModeReqAttitude = 0
	t.ModeReqLocalAlt = 0
	t.ModeReqLocalPosition = 0
	t.ModeReqLocalPositionRelaxed = 0
	t.ModeReqGlobalPosition = 0
	t.ModeReqMission = 0
	t.ModeReqOffboardSignal = 0
	t.ModeReqHomePosition = 0
	t.ModeReqWindAndFlightTimeCompliance = 0
	t.ModeReqPreventArming = 0
	t.ModeReqManualControl = 0
	t.ModeReqOther = 0
	t.AngularVelocityInvalid = false
	t.AttitudeInvalid = false
	t.LocalAltitudeInvalid = false
	t.LocalPositionInvalid = false
	t.LocalPositionInvalidRelaxed = false
	t.LocalVelocityInvalid = false
	t.GlobalPositionInvalid = false
	t.AutoMissionMissing = false
	t.OffboardControlSignalLost = false
	t.HomePositionInvalid = false
	t.ManualControlSignalLost = false
	t.GcsConnectionLost = false
	t.BatteryWarning = 0
	t.BatteryLowRemainingTime = false
	t.BatteryUnhealthy = false
	t.GeofenceBreached = false
	t.MissionFailure = false
	t.VtolFixedWingSystemFailure = false
	t.WindLimitExceeded = false
	t.FlightTimeLimitExceeded = false
	t.LocalPositionAccuracyLow = false
	t.NavigatorFailure = false
	t.FdCriticalFailure = false
	t.FdEscArmingFailure = false
	t.FdImbalancedProp = false
	t.FdMotorFailure = false
}

func (t *FailsafeFlags) GetTypeSupport() types.MessageTypeSupport {
	return FailsafeFlagsTypeSupport
}

// FailsafeFlagsPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type FailsafeFlagsPublisher struct {
	*rclgo.Publisher
}

// NewFailsafeFlagsPublisher creates and returns a new publisher for the
// FailsafeFlags
func NewFailsafeFlagsPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*FailsafeFlagsPublisher, error) {
	pub, err := node.NewPublisher(topic_name, FailsafeFlagsTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &FailsafeFlagsPublisher{pub}, nil
}

func (p *FailsafeFlagsPublisher) Publish(msg *FailsafeFlags) error {
	return p.Publisher.Publish(msg)
}

// FailsafeFlagsSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type FailsafeFlagsSubscription struct {
	*rclgo.Subscription
}

// FailsafeFlagsSubscriptionCallback type is used to provide a subscription
// handler function for a FailsafeFlagsSubscription.
type FailsafeFlagsSubscriptionCallback func(msg *FailsafeFlags, info *rclgo.MessageInfo, err error)

// NewFailsafeFlagsSubscription creates and returns a new subscription for the
// FailsafeFlags
func NewFailsafeFlagsSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback FailsafeFlagsSubscriptionCallback) (*FailsafeFlagsSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg FailsafeFlags
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, FailsafeFlagsTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &FailsafeFlagsSubscription{sub}, nil
}

func (s *FailsafeFlagsSubscription) TakeMessage(out *FailsafeFlags) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneFailsafeFlagsSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneFailsafeFlagsSlice(dst, src []FailsafeFlags) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var FailsafeFlagsTypeSupport types.MessageTypeSupport = _FailsafeFlagsTypeSupport{}

type _FailsafeFlagsTypeSupport struct{}

func (t _FailsafeFlagsTypeSupport) New() types.Message {
	return NewFailsafeFlags()
}

func (t _FailsafeFlagsTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__FailsafeFlags
	return (unsafe.Pointer)(C.px4_msgs__msg__FailsafeFlags__create())
}

func (t _FailsafeFlagsTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__FailsafeFlags__destroy((*C.px4_msgs__msg__FailsafeFlags)(pointer_to_free))
}

func (t _FailsafeFlagsTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*FailsafeFlags)
	mem := (*C.px4_msgs__msg__FailsafeFlags)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.mode_req_angular_velocity = C.uint32_t(m.ModeReqAngularVelocity)
	mem.mode_req_attitude = C.uint32_t(m.ModeReqAttitude)
	mem.mode_req_local_alt = C.uint32_t(m.ModeReqLocalAlt)
	mem.mode_req_local_position = C.uint32_t(m.ModeReqLocalPosition)
	mem.mode_req_local_position_relaxed = C.uint32_t(m.ModeReqLocalPositionRelaxed)
	mem.mode_req_global_position = C.uint32_t(m.ModeReqGlobalPosition)
	mem.mode_req_mission = C.uint32_t(m.ModeReqMission)
	mem.mode_req_offboard_signal = C.uint32_t(m.ModeReqOffboardSignal)
	mem.mode_req_home_position = C.uint32_t(m.ModeReqHomePosition)
	mem.mode_req_wind_and_flight_time_compliance = C.uint32_t(m.ModeReqWindAndFlightTimeCompliance)
	mem.mode_req_prevent_arming = C.uint32_t(m.ModeReqPreventArming)
	mem.mode_req_manual_control = C.uint32_t(m.ModeReqManualControl)
	mem.mode_req_other = C.uint32_t(m.ModeReqOther)
	mem.angular_velocity_invalid = C.bool(m.AngularVelocityInvalid)
	mem.attitude_invalid = C.bool(m.AttitudeInvalid)
	mem.local_altitude_invalid = C.bool(m.LocalAltitudeInvalid)
	mem.local_position_invalid = C.bool(m.LocalPositionInvalid)
	mem.local_position_invalid_relaxed = C.bool(m.LocalPositionInvalidRelaxed)
	mem.local_velocity_invalid = C.bool(m.LocalVelocityInvalid)
	mem.global_position_invalid = C.bool(m.GlobalPositionInvalid)
	mem.auto_mission_missing = C.bool(m.AutoMissionMissing)
	mem.offboard_control_signal_lost = C.bool(m.OffboardControlSignalLost)
	mem.home_position_invalid = C.bool(m.HomePositionInvalid)
	mem.manual_control_signal_lost = C.bool(m.ManualControlSignalLost)
	mem.gcs_connection_lost = C.bool(m.GcsConnectionLost)
	mem.battery_warning = C.uint8_t(m.BatteryWarning)
	mem.battery_low_remaining_time = C.bool(m.BatteryLowRemainingTime)
	mem.battery_unhealthy = C.bool(m.BatteryUnhealthy)
	mem.geofence_breached = C.bool(m.GeofenceBreached)
	mem.mission_failure = C.bool(m.MissionFailure)
	mem.vtol_fixed_wing_system_failure = C.bool(m.VtolFixedWingSystemFailure)
	mem.wind_limit_exceeded = C.bool(m.WindLimitExceeded)
	mem.flight_time_limit_exceeded = C.bool(m.FlightTimeLimitExceeded)
	mem.local_position_accuracy_low = C.bool(m.LocalPositionAccuracyLow)
	mem.navigator_failure = C.bool(m.NavigatorFailure)
	mem.fd_critical_failure = C.bool(m.FdCriticalFailure)
	mem.fd_esc_arming_failure = C.bool(m.FdEscArmingFailure)
	mem.fd_imbalanced_prop = C.bool(m.FdImbalancedProp)
	mem.fd_motor_failure = C.bool(m.FdMotorFailure)
}

func (t _FailsafeFlagsTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*FailsafeFlags)
	mem := (*C.px4_msgs__msg__FailsafeFlags)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.ModeReqAngularVelocity = uint32(mem.mode_req_angular_velocity)
	m.ModeReqAttitude = uint32(mem.mode_req_attitude)
	m.ModeReqLocalAlt = uint32(mem.mode_req_local_alt)
	m.ModeReqLocalPosition = uint32(mem.mode_req_local_position)
	m.ModeReqLocalPositionRelaxed = uint32(mem.mode_req_local_position_relaxed)
	m.ModeReqGlobalPosition = uint32(mem.mode_req_global_position)
	m.ModeReqMission = uint32(mem.mode_req_mission)
	m.ModeReqOffboardSignal = uint32(mem.mode_req_offboard_signal)
	m.ModeReqHomePosition = uint32(mem.mode_req_home_position)
	m.ModeReqWindAndFlightTimeCompliance = uint32(mem.mode_req_wind_and_flight_time_compliance)
	m.ModeReqPreventArming = uint32(mem.mode_req_prevent_arming)
	m.ModeReqManualControl = uint32(mem.mode_req_manual_control)
	m.ModeReqOther = uint32(mem.mode_req_other)
	m.AngularVelocityInvalid = bool(mem.angular_velocity_invalid)
	m.AttitudeInvalid = bool(mem.attitude_invalid)
	m.LocalAltitudeInvalid = bool(mem.local_altitude_invalid)
	m.LocalPositionInvalid = bool(mem.local_position_invalid)
	m.LocalPositionInvalidRelaxed = bool(mem.local_position_invalid_relaxed)
	m.LocalVelocityInvalid = bool(mem.local_velocity_invalid)
	m.GlobalPositionInvalid = bool(mem.global_position_invalid)
	m.AutoMissionMissing = bool(mem.auto_mission_missing)
	m.OffboardControlSignalLost = bool(mem.offboard_control_signal_lost)
	m.HomePositionInvalid = bool(mem.home_position_invalid)
	m.ManualControlSignalLost = bool(mem.manual_control_signal_lost)
	m.GcsConnectionLost = bool(mem.gcs_connection_lost)
	m.BatteryWarning = uint8(mem.battery_warning)
	m.BatteryLowRemainingTime = bool(mem.battery_low_remaining_time)
	m.BatteryUnhealthy = bool(mem.battery_unhealthy)
	m.GeofenceBreached = bool(mem.geofence_breached)
	m.MissionFailure = bool(mem.mission_failure)
	m.VtolFixedWingSystemFailure = bool(mem.vtol_fixed_wing_system_failure)
	m.WindLimitExceeded = bool(mem.wind_limit_exceeded)
	m.FlightTimeLimitExceeded = bool(mem.flight_time_limit_exceeded)
	m.LocalPositionAccuracyLow = bool(mem.local_position_accuracy_low)
	m.NavigatorFailure = bool(mem.navigator_failure)
	m.FdCriticalFailure = bool(mem.fd_critical_failure)
	m.FdEscArmingFailure = bool(mem.fd_esc_arming_failure)
	m.FdImbalancedProp = bool(mem.fd_imbalanced_prop)
	m.FdMotorFailure = bool(mem.fd_motor_failure)
}

func (t _FailsafeFlagsTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__FailsafeFlags())
}

type CFailsafeFlags = C.px4_msgs__msg__FailsafeFlags
type CFailsafeFlags__Sequence = C.px4_msgs__msg__FailsafeFlags__Sequence

func FailsafeFlags__Sequence_to_Go(goSlice *[]FailsafeFlags, cSlice CFailsafeFlags__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]FailsafeFlags, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		FailsafeFlagsTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func FailsafeFlags__Sequence_to_C(cSlice *CFailsafeFlags__Sequence, goSlice []FailsafeFlags) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.px4_msgs__msg__FailsafeFlags)(C.malloc(C.sizeof_struct_px4_msgs__msg__FailsafeFlags * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		FailsafeFlagsTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func FailsafeFlags__Array_to_Go(goSlice []FailsafeFlags, cSlice []CFailsafeFlags) {
	for i := 0; i < len(cSlice); i++ {
		FailsafeFlagsTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func FailsafeFlags__Array_to_C(cSlice []CFailsafeFlags, goSlice []FailsafeFlags) {
	for i := 0; i < len(goSlice); i++ {
		FailsafeFlagsTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
