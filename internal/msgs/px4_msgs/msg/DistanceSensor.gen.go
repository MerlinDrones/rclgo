// Code generated by rclgo-gen. DO NOT EDIT.

package px4_msgs_msg

import (
	"unsafe"

	"github.com/merlindrones/rclgo/pkg/rclgo"
	primitives "github.com/merlindrones/rclgo/pkg/rclgo/primitives"
	"github.com/merlindrones/rclgo/pkg/rclgo/typemap"
	"github.com/merlindrones/rclgo/pkg/rclgo/types"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/distance_sensor.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/DistanceSensor", DistanceSensorTypeSupport)
	typemap.RegisterMessage("px4_msgs/msg/DistanceSensor", DistanceSensorTypeSupport)
}

const (
	DistanceSensor_MAV_DISTANCE_SENSOR_LASER      uint8 = 0
	DistanceSensor_MAV_DISTANCE_SENSOR_ULTRASOUND uint8 = 1
	DistanceSensor_MAV_DISTANCE_SENSOR_INFRARED   uint8 = 2
	DistanceSensor_MAV_DISTANCE_SENSOR_RADAR      uint8 = 3
	DistanceSensor_ROTATION_YAW_0                 uint8 = 0   // MAV_SENSOR_ROTATION_NONE
	DistanceSensor_ROTATION_YAW_45                uint8 = 1   // MAV_SENSOR_ROTATION_YAW_45
	DistanceSensor_ROTATION_YAW_90                uint8 = 2   // MAV_SENSOR_ROTATION_YAW_90
	DistanceSensor_ROTATION_YAW_135               uint8 = 3   // MAV_SENSOR_ROTATION_YAW_135
	DistanceSensor_ROTATION_YAW_180               uint8 = 4   // MAV_SENSOR_ROTATION_YAW_180
	DistanceSensor_ROTATION_YAW_225               uint8 = 5   // MAV_SENSOR_ROTATION_YAW_225
	DistanceSensor_ROTATION_YAW_270               uint8 = 6   // MAV_SENSOR_ROTATION_YAW_270
	DistanceSensor_ROTATION_YAW_315               uint8 = 7   // MAV_SENSOR_ROTATION_YAW_315
	DistanceSensor_ROTATION_FORWARD_FACING        uint8 = 0   // MAV_SENSOR_ROTATION_NONE
	DistanceSensor_ROTATION_RIGHT_FACING          uint8 = 2   // MAV_SENSOR_ROTATION_YAW_90
	DistanceSensor_ROTATION_BACKWARD_FACING       uint8 = 4   // MAV_SENSOR_ROTATION_YAW_180
	DistanceSensor_ROTATION_LEFT_FACING           uint8 = 6   // MAV_SENSOR_ROTATION_YAW_270
	DistanceSensor_ROTATION_UPWARD_FACING         uint8 = 24  // MAV_SENSOR_ROTATION_PITCH_90
	DistanceSensor_ROTATION_DOWNWARD_FACING       uint8 = 25  // MAV_SENSOR_ROTATION_PITCH_270
	DistanceSensor_ROTATION_CUSTOM                uint8 = 100 // MAV_SENSOR_ROTATION_CUSTOM
	DistanceSensor_MODE_UNKNOWN                   uint8 = 0
	DistanceSensor_MODE_ENABLED                   uint8 = 1
	DistanceSensor_MODE_DISABLED                  uint8 = 2
)

type DistanceSensor struct {
	Timestamp       uint64     `yaml:"timestamp"`        // time since system start (microseconds)
	DeviceId        uint32     `yaml:"device_id"`        // unique device ID for the sensor that does not change between power cycles
	MinDistance     float32    `yaml:"min_distance"`     // Minimum distance the sensor can measure (in m)
	MaxDistance     float32    `yaml:"max_distance"`     // Maximum distance the sensor can measure (in m)
	CurrentDistance float32    `yaml:"current_distance"` // Current distance reading (in m)
	Variance        float32    `yaml:"variance"`         // Measurement variance (in m^2), 0 for unknown / invalid readings
	SignalQuality   int8       `yaml:"signal_quality"`   // Signal quality in percent (0...100%), where 0 = invalid signal, 100 = perfect signal, and -1 = unknown signal quality.
	Type            uint8      `yaml:"type"`             // Type from MAV_DISTANCE_SENSOR enum
	HFov            float32    `yaml:"h_fov"`            // Sensor horizontal field of view (rad)
	VFov            float32    `yaml:"v_fov"`            // Sensor vertical field of view (rad)
	Q               [4]float32 `yaml:"q"`                // Quaterion sensor orientation with respect to the vehicle body frame to specify the orientation ROTATION_CUSTOM
	Orientation     uint8      `yaml:"orientation"`      // Direction the sensor faces from MAV_SENSOR_ORIENTATION enum
	Mode            uint8      `yaml:"mode"`
}

// NewDistanceSensor creates a new DistanceSensor with default values.
func NewDistanceSensor() *DistanceSensor {
	self := DistanceSensor{}
	self.SetDefaults()
	return &self
}

func (t *DistanceSensor) Clone() *DistanceSensor {
	c := &DistanceSensor{}
	c.Timestamp = t.Timestamp
	c.DeviceId = t.DeviceId
	c.MinDistance = t.MinDistance
	c.MaxDistance = t.MaxDistance
	c.CurrentDistance = t.CurrentDistance
	c.Variance = t.Variance
	c.SignalQuality = t.SignalQuality
	c.Type = t.Type
	c.HFov = t.HFov
	c.VFov = t.VFov
	c.Q = t.Q
	c.Orientation = t.Orientation
	c.Mode = t.Mode
	return c
}

func (t *DistanceSensor) CloneMsg() types.Message {
	return t.Clone()
}

func (t *DistanceSensor) SetDefaults() {
	t.Timestamp = 0
	t.DeviceId = 0
	t.MinDistance = 0
	t.MaxDistance = 0
	t.CurrentDistance = 0
	t.Variance = 0
	t.SignalQuality = 0
	t.Type = 0
	t.HFov = 0
	t.VFov = 0
	t.Q = [4]float32{}
	t.Orientation = 0
	t.Mode = 0
}

func (t *DistanceSensor) GetTypeSupport() types.MessageTypeSupport {
	return DistanceSensorTypeSupport
}

// DistanceSensorPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type DistanceSensorPublisher struct {
	*rclgo.Publisher
}

// NewDistanceSensorPublisher creates and returns a new publisher for the
// DistanceSensor
func NewDistanceSensorPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*DistanceSensorPublisher, error) {
	pub, err := node.NewPublisher(topic_name, DistanceSensorTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &DistanceSensorPublisher{pub}, nil
}

func (p *DistanceSensorPublisher) Publish(msg *DistanceSensor) error {
	return p.Publisher.Publish(msg)
}

// DistanceSensorSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type DistanceSensorSubscription struct {
	*rclgo.Subscription
}

// DistanceSensorSubscriptionCallback type is used to provide a subscription
// handler function for a DistanceSensorSubscription.
type DistanceSensorSubscriptionCallback func(msg *DistanceSensor, info *rclgo.MessageInfo, err error)

// NewDistanceSensorSubscription creates and returns a new subscription for the
// DistanceSensor
func NewDistanceSensorSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback DistanceSensorSubscriptionCallback) (*DistanceSensorSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg DistanceSensor
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, DistanceSensorTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &DistanceSensorSubscription{sub}, nil
}

func (s *DistanceSensorSubscription) TakeMessage(out *DistanceSensor) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneDistanceSensorSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneDistanceSensorSlice(dst, src []DistanceSensor) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var DistanceSensorTypeSupport types.MessageTypeSupport = _DistanceSensorTypeSupport{}

type _DistanceSensorTypeSupport struct{}

func (t _DistanceSensorTypeSupport) New() types.Message {
	return NewDistanceSensor()
}

func (t _DistanceSensorTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__DistanceSensor
	return (unsafe.Pointer)(C.px4_msgs__msg__DistanceSensor__create())
}

func (t _DistanceSensorTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__DistanceSensor__destroy((*C.px4_msgs__msg__DistanceSensor)(pointer_to_free))
}

func (t _DistanceSensorTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*DistanceSensor)
	mem := (*C.px4_msgs__msg__DistanceSensor)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.device_id = C.uint32_t(m.DeviceId)
	mem.min_distance = C.float(m.MinDistance)
	mem.max_distance = C.float(m.MaxDistance)
	mem.current_distance = C.float(m.CurrentDistance)
	mem.variance = C.float(m.Variance)
	mem.signal_quality = C.int8_t(m.SignalQuality)
	mem._type = C.uint8_t(m.Type)
	mem.h_fov = C.float(m.HFov)
	mem.v_fov = C.float(m.VFov)
	cSlice_q := mem.q[:]
	primitives.Float32__Array_to_C(*(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_q)), m.Q[:])
	mem.orientation = C.uint8_t(m.Orientation)
	mem.mode = C.uint8_t(m.Mode)
}

func (t _DistanceSensorTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*DistanceSensor)
	mem := (*C.px4_msgs__msg__DistanceSensor)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.DeviceId = uint32(mem.device_id)
	m.MinDistance = float32(mem.min_distance)
	m.MaxDistance = float32(mem.max_distance)
	m.CurrentDistance = float32(mem.current_distance)
	m.Variance = float32(mem.variance)
	m.SignalQuality = int8(mem.signal_quality)
	m.Type = uint8(mem._type)
	m.HFov = float32(mem.h_fov)
	m.VFov = float32(mem.v_fov)
	cSlice_q := mem.q[:]
	primitives.Float32__Array_to_Go(m.Q[:], *(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_q)))
	m.Orientation = uint8(mem.orientation)
	m.Mode = uint8(mem.mode)
}

func (t _DistanceSensorTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__DistanceSensor())
}

type CDistanceSensor = C.px4_msgs__msg__DistanceSensor
type CDistanceSensor__Sequence = C.px4_msgs__msg__DistanceSensor__Sequence

func DistanceSensor__Sequence_to_Go(goSlice *[]DistanceSensor, cSlice CDistanceSensor__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]DistanceSensor, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		DistanceSensorTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func DistanceSensor__Sequence_to_C(cSlice *CDistanceSensor__Sequence, goSlice []DistanceSensor) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.px4_msgs__msg__DistanceSensor)(C.malloc(C.sizeof_struct_px4_msgs__msg__DistanceSensor * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		DistanceSensorTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func DistanceSensor__Array_to_Go(goSlice []DistanceSensor, cSlice []CDistanceSensor) {
	for i := 0; i < len(cSlice); i++ {
		DistanceSensorTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func DistanceSensor__Array_to_C(cSlice []CDistanceSensor, goSlice []DistanceSensor) {
	for i := 0; i < len(goSlice); i++ {
		DistanceSensorTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
