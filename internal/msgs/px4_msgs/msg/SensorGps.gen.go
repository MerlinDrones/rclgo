// Code generated by rclgo-gen. DO NOT EDIT.

package px4_msgs_msg

import (
	"unsafe"

	"github.com/merlindrones/rclgo/pkg/rclgo"
	"github.com/merlindrones/rclgo/pkg/rclgo/typemap"
	"github.com/merlindrones/rclgo/pkg/rclgo/types"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/sensor_gps.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/SensorGps", SensorGpsTypeSupport)
	typemap.RegisterMessage("px4_msgs/msg/SensorGps", SensorGpsTypeSupport)
}

const (
	SensorGps_FIX_TYPE_NONE                   uint8 = 1 // Value 0 is also valid to represent no fix.
	SensorGps_FIX_TYPE_2D                     uint8 = 2
	SensorGps_FIX_TYPE_3D                     uint8 = 3
	SensorGps_FIX_TYPE_RTCM_CODE_DIFFERENTIAL uint8 = 4
	SensorGps_FIX_TYPE_RTK_FLOAT              uint8 = 5
	SensorGps_FIX_TYPE_RTK_FIXED              uint8 = 6
	SensorGps_FIX_TYPE_EXTRAPOLATED           uint8 = 8
	SensorGps_JAMMING_STATE_UNKNOWN           uint8 = 0
	SensorGps_JAMMING_STATE_OK                uint8 = 1
	SensorGps_JAMMING_STATE_WARNING           uint8 = 2
	SensorGps_JAMMING_STATE_CRITICAL          uint8 = 3
	SensorGps_SPOOFING_STATE_UNKNOWN          uint8 = 0
	SensorGps_SPOOFING_STATE_NONE             uint8 = 1
	SensorGps_SPOOFING_STATE_INDICATED        uint8 = 2
	SensorGps_SPOOFING_STATE_MULTIPLE         uint8 = 3
	SensorGps_RTCM_MSG_USED_UNKNOWN           uint8 = 0
	SensorGps_RTCM_MSG_USED_NOT_USED          uint8 = 1
	SensorGps_RTCM_MSG_USED_USED              uint8 = 2
)

type SensorGps struct {
	Timestamp             uint64  `yaml:"timestamp"` // time since system start (microseconds). GPS position in WGS84 coordinates.the field 'timestamp' is for the position & velocity (microseconds)
	TimestampSample       uint64  `yaml:"timestamp_sample"`
	DeviceId              uint32  `yaml:"device_id"`               // unique device ID for the sensor that does not change between power cycles
	LatitudeDeg           float64 `yaml:"latitude_deg"`            // Latitude in degrees, allows centimeter level RTK precision
	LongitudeDeg          float64 `yaml:"longitude_deg"`           // Longitude in degrees, allows centimeter level RTK precision
	AltitudeMslM          float64 `yaml:"altitude_msl_m"`          // Altitude above MSL, meters
	AltitudeEllipsoidM    float64 `yaml:"altitude_ellipsoid_m"`    // Altitude above Ellipsoid, meters
	SVarianceMS           float32 `yaml:"s_variance_m_s"`          // GPS speed accuracy estimate, (metres/sec)
	CVarianceRad          float32 `yaml:"c_variance_rad"`          // GPS course accuracy estimate, (radians)
	FixType               uint8   `yaml:"fix_type"`                // Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
	Eph                   float32 `yaml:"eph"`                     // GPS horizontal position accuracy (metres)
	Epv                   float32 `yaml:"epv"`                     // GPS vertical position accuracy (metres)
	Hdop                  float32 `yaml:"hdop"`                    // Horizontal dilution of precision
	Vdop                  float32 `yaml:"vdop"`                    // Vertical dilution of precision
	NoisePerMs            int32   `yaml:"noise_per_ms"`            // GPS noise per millisecond
	AutomaticGainControl  uint16  `yaml:"automatic_gain_control"`  // Automatic gain control monitor
	JammingState          uint8   `yaml:"jamming_state"`           // indicates whether jamming has been detected or suspected by the receivers. O: Unknown, 1: OK, 2: Warning, 3: Critical
	JammingIndicator      int32   `yaml:"jamming_indicator"`       // indicates jamming is occurring
	SpoofingState         uint8   `yaml:"spoofing_state"`          // indicates whether spoofing has been detected or suspected by the receivers. O: Unknown, 1: OK, 2: Warning, 3: Critical
	VelMS                 float32 `yaml:"vel_m_s"`                 // GPS ground speed, (metres/sec)
	VelNMS                float32 `yaml:"vel_n_m_s"`               // GPS North velocity, (metres/sec)
	VelEMS                float32 `yaml:"vel_e_m_s"`               // GPS East velocity, (metres/sec)
	VelDMS                float32 `yaml:"vel_d_m_s"`               // GPS Down velocity, (metres/sec)
	CogRad                float32 `yaml:"cog_rad"`                 // Course over ground (NOT heading, but direction of movement), -PI..PI, (radians)
	VelNedValid           bool    `yaml:"vel_ned_valid"`           // True if NED velocity is valid
	TimestampTimeRelative int32   `yaml:"timestamp_time_relative"` // timestamp + timestamp_time_relative = Time of the UTC timestamp since system start, (microseconds)
	TimeUtcUsec           uint64  `yaml:"time_utc_usec"`           // Timestamp (microseconds, UTC), this is the timestamp which comes from the gps module. It might be unavailable right after cold start, indicated by a value of 0
	SatellitesUsed        uint8   `yaml:"satellites_used"`         // Number of satellites used
	Heading               float32 `yaml:"heading"`                 // heading angle of XYZ body frame rel to NED. Set to NaN if not available and updated (used for dual antenna GPS), (rad, [-PI, PI])
	HeadingOffset         float32 `yaml:"heading_offset"`          // heading offset of dual antenna array in body frame. Set to NaN if not applicable. (rad, [-PI, PI])
	HeadingAccuracy       float32 `yaml:"heading_accuracy"`        // heading accuracy (rad, [0, 2PI])
	RtcmInjectionRate     float32 `yaml:"rtcm_injection_rate"`     // RTCM message injection rate Hz
	SelectedRtcmInstance  uint8   `yaml:"selected_rtcm_instance"`  // uorb instance that is being used for RTCM corrections
	RtcmCrcFailed         bool    `yaml:"rtcm_crc_failed"`         // RTCM message CRC failure detected
	RtcmMsgUsed           uint8   `yaml:"rtcm_msg_used"`           // Indicates if the RTCM message was used successfully by the receiver
}

// NewSensorGps creates a new SensorGps with default values.
func NewSensorGps() *SensorGps {
	self := SensorGps{}
	self.SetDefaults()
	return &self
}

func (t *SensorGps) Clone() *SensorGps {
	c := &SensorGps{}
	c.Timestamp = t.Timestamp
	c.TimestampSample = t.TimestampSample
	c.DeviceId = t.DeviceId
	c.LatitudeDeg = t.LatitudeDeg
	c.LongitudeDeg = t.LongitudeDeg
	c.AltitudeMslM = t.AltitudeMslM
	c.AltitudeEllipsoidM = t.AltitudeEllipsoidM
	c.SVarianceMS = t.SVarianceMS
	c.CVarianceRad = t.CVarianceRad
	c.FixType = t.FixType
	c.Eph = t.Eph
	c.Epv = t.Epv
	c.Hdop = t.Hdop
	c.Vdop = t.Vdop
	c.NoisePerMs = t.NoisePerMs
	c.AutomaticGainControl = t.AutomaticGainControl
	c.JammingState = t.JammingState
	c.JammingIndicator = t.JammingIndicator
	c.SpoofingState = t.SpoofingState
	c.VelMS = t.VelMS
	c.VelNMS = t.VelNMS
	c.VelEMS = t.VelEMS
	c.VelDMS = t.VelDMS
	c.CogRad = t.CogRad
	c.VelNedValid = t.VelNedValid
	c.TimestampTimeRelative = t.TimestampTimeRelative
	c.TimeUtcUsec = t.TimeUtcUsec
	c.SatellitesUsed = t.SatellitesUsed
	c.Heading = t.Heading
	c.HeadingOffset = t.HeadingOffset
	c.HeadingAccuracy = t.HeadingAccuracy
	c.RtcmInjectionRate = t.RtcmInjectionRate
	c.SelectedRtcmInstance = t.SelectedRtcmInstance
	c.RtcmCrcFailed = t.RtcmCrcFailed
	c.RtcmMsgUsed = t.RtcmMsgUsed
	return c
}

func (t *SensorGps) CloneMsg() types.Message {
	return t.Clone()
}

func (t *SensorGps) SetDefaults() {
	t.Timestamp = 0
	t.TimestampSample = 0
	t.DeviceId = 0
	t.LatitudeDeg = 0
	t.LongitudeDeg = 0
	t.AltitudeMslM = 0
	t.AltitudeEllipsoidM = 0
	t.SVarianceMS = 0
	t.CVarianceRad = 0
	t.FixType = 0
	t.Eph = 0
	t.Epv = 0
	t.Hdop = 0
	t.Vdop = 0
	t.NoisePerMs = 0
	t.AutomaticGainControl = 0
	t.JammingState = 0
	t.JammingIndicator = 0
	t.SpoofingState = 0
	t.VelMS = 0
	t.VelNMS = 0
	t.VelEMS = 0
	t.VelDMS = 0
	t.CogRad = 0
	t.VelNedValid = false
	t.TimestampTimeRelative = 0
	t.TimeUtcUsec = 0
	t.SatellitesUsed = 0
	t.Heading = 0
	t.HeadingOffset = 0
	t.HeadingAccuracy = 0
	t.RtcmInjectionRate = 0
	t.SelectedRtcmInstance = 0
	t.RtcmCrcFailed = false
	t.RtcmMsgUsed = 0
}

func (t *SensorGps) GetTypeSupport() types.MessageTypeSupport {
	return SensorGpsTypeSupport
}

// SensorGpsPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type SensorGpsPublisher struct {
	*rclgo.Publisher
}

// NewSensorGpsPublisher creates and returns a new publisher for the
// SensorGps
func NewSensorGpsPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*SensorGpsPublisher, error) {
	pub, err := node.NewPublisher(topic_name, SensorGpsTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &SensorGpsPublisher{pub}, nil
}

func (p *SensorGpsPublisher) Publish(msg *SensorGps) error {
	return p.Publisher.Publish(msg)
}

// SensorGpsSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type SensorGpsSubscription struct {
	*rclgo.Subscription
}

// SensorGpsSubscriptionCallback type is used to provide a subscription
// handler function for a SensorGpsSubscription.
type SensorGpsSubscriptionCallback func(msg *SensorGps, info *rclgo.MessageInfo, err error)

// NewSensorGpsSubscription creates and returns a new subscription for the
// SensorGps
func NewSensorGpsSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback SensorGpsSubscriptionCallback) (*SensorGpsSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg SensorGps
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, SensorGpsTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &SensorGpsSubscription{sub}, nil
}

func (s *SensorGpsSubscription) TakeMessage(out *SensorGps) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneSensorGpsSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneSensorGpsSlice(dst, src []SensorGps) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var SensorGpsTypeSupport types.MessageTypeSupport = _SensorGpsTypeSupport{}

type _SensorGpsTypeSupport struct{}

func (t _SensorGpsTypeSupport) New() types.Message {
	return NewSensorGps()
}

func (t _SensorGpsTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__SensorGps
	return (unsafe.Pointer)(C.px4_msgs__msg__SensorGps__create())
}

func (t _SensorGpsTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__SensorGps__destroy((*C.px4_msgs__msg__SensorGps)(pointer_to_free))
}

func (t _SensorGpsTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*SensorGps)
	mem := (*C.px4_msgs__msg__SensorGps)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.timestamp_sample = C.uint64_t(m.TimestampSample)
	mem.device_id = C.uint32_t(m.DeviceId)
	mem.latitude_deg = C.double(m.LatitudeDeg)
	mem.longitude_deg = C.double(m.LongitudeDeg)
	mem.altitude_msl_m = C.double(m.AltitudeMslM)
	mem.altitude_ellipsoid_m = C.double(m.AltitudeEllipsoidM)
	mem.s_variance_m_s = C.float(m.SVarianceMS)
	mem.c_variance_rad = C.float(m.CVarianceRad)
	mem.fix_type = C.uint8_t(m.FixType)
	mem.eph = C.float(m.Eph)
	mem.epv = C.float(m.Epv)
	mem.hdop = C.float(m.Hdop)
	mem.vdop = C.float(m.Vdop)
	mem.noise_per_ms = C.int32_t(m.NoisePerMs)
	mem.automatic_gain_control = C.uint16_t(m.AutomaticGainControl)
	mem.jamming_state = C.uint8_t(m.JammingState)
	mem.jamming_indicator = C.int32_t(m.JammingIndicator)
	mem.spoofing_state = C.uint8_t(m.SpoofingState)
	mem.vel_m_s = C.float(m.VelMS)
	mem.vel_n_m_s = C.float(m.VelNMS)
	mem.vel_e_m_s = C.float(m.VelEMS)
	mem.vel_d_m_s = C.float(m.VelDMS)
	mem.cog_rad = C.float(m.CogRad)
	mem.vel_ned_valid = C.bool(m.VelNedValid)
	mem.timestamp_time_relative = C.int32_t(m.TimestampTimeRelative)
	mem.time_utc_usec = C.uint64_t(m.TimeUtcUsec)
	mem.satellites_used = C.uint8_t(m.SatellitesUsed)
	mem.heading = C.float(m.Heading)
	mem.heading_offset = C.float(m.HeadingOffset)
	mem.heading_accuracy = C.float(m.HeadingAccuracy)
	mem.rtcm_injection_rate = C.float(m.RtcmInjectionRate)
	mem.selected_rtcm_instance = C.uint8_t(m.SelectedRtcmInstance)
	mem.rtcm_crc_failed = C.bool(m.RtcmCrcFailed)
	mem.rtcm_msg_used = C.uint8_t(m.RtcmMsgUsed)
}

func (t _SensorGpsTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*SensorGps)
	mem := (*C.px4_msgs__msg__SensorGps)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.TimestampSample = uint64(mem.timestamp_sample)
	m.DeviceId = uint32(mem.device_id)
	m.LatitudeDeg = float64(mem.latitude_deg)
	m.LongitudeDeg = float64(mem.longitude_deg)
	m.AltitudeMslM = float64(mem.altitude_msl_m)
	m.AltitudeEllipsoidM = float64(mem.altitude_ellipsoid_m)
	m.SVarianceMS = float32(mem.s_variance_m_s)
	m.CVarianceRad = float32(mem.c_variance_rad)
	m.FixType = uint8(mem.fix_type)
	m.Eph = float32(mem.eph)
	m.Epv = float32(mem.epv)
	m.Hdop = float32(mem.hdop)
	m.Vdop = float32(mem.vdop)
	m.NoisePerMs = int32(mem.noise_per_ms)
	m.AutomaticGainControl = uint16(mem.automatic_gain_control)
	m.JammingState = uint8(mem.jamming_state)
	m.JammingIndicator = int32(mem.jamming_indicator)
	m.SpoofingState = uint8(mem.spoofing_state)
	m.VelMS = float32(mem.vel_m_s)
	m.VelNMS = float32(mem.vel_n_m_s)
	m.VelEMS = float32(mem.vel_e_m_s)
	m.VelDMS = float32(mem.vel_d_m_s)
	m.CogRad = float32(mem.cog_rad)
	m.VelNedValid = bool(mem.vel_ned_valid)
	m.TimestampTimeRelative = int32(mem.timestamp_time_relative)
	m.TimeUtcUsec = uint64(mem.time_utc_usec)
	m.SatellitesUsed = uint8(mem.satellites_used)
	m.Heading = float32(mem.heading)
	m.HeadingOffset = float32(mem.heading_offset)
	m.HeadingAccuracy = float32(mem.heading_accuracy)
	m.RtcmInjectionRate = float32(mem.rtcm_injection_rate)
	m.SelectedRtcmInstance = uint8(mem.selected_rtcm_instance)
	m.RtcmCrcFailed = bool(mem.rtcm_crc_failed)
	m.RtcmMsgUsed = uint8(mem.rtcm_msg_used)
}

func (t _SensorGpsTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__SensorGps())
}

type CSensorGps = C.px4_msgs__msg__SensorGps
type CSensorGps__Sequence = C.px4_msgs__msg__SensorGps__Sequence

func SensorGps__Sequence_to_Go(goSlice *[]SensorGps, cSlice CSensorGps__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]SensorGps, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		SensorGpsTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func SensorGps__Sequence_to_C(cSlice *CSensorGps__Sequence, goSlice []SensorGps) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.px4_msgs__msg__SensorGps)(C.malloc(C.sizeof_struct_px4_msgs__msg__SensorGps * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		SensorGpsTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func SensorGps__Array_to_Go(goSlice []SensorGps, cSlice []CSensorGps) {
	for i := 0; i < len(cSlice); i++ {
		SensorGpsTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func SensorGps__Array_to_C(cSlice []CSensorGps, goSlice []SensorGps) {
	for i := 0; i < len(goSlice); i++ {
		SensorGpsTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
