// Code generated by rclgo-gen. DO NOT EDIT.

package px4_msgs_msg

import (
	"unsafe"

	"github.com/merlindrones/rclgo/pkg/rclgo"
	primitives "github.com/merlindrones/rclgo/pkg/rclgo/primitives"
	"github.com/merlindrones/rclgo/pkg/rclgo/typemap"
	"github.com/merlindrones/rclgo/pkg/rclgo/types"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/vehicle_optical_flow_vel.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/VehicleOpticalFlowVel", VehicleOpticalFlowVelTypeSupport)
	typemap.RegisterMessage("px4_msgs/msg/VehicleOpticalFlowVel", VehicleOpticalFlowVelTypeSupport)
}

type VehicleOpticalFlowVel struct {
	Timestamp             uint64     `yaml:"timestamp"`               // time since system start (microseconds)
	TimestampSample       uint64     `yaml:"timestamp_sample"`        // the timestamp of the raw data (microseconds)
	VelBody               [2]float32 `yaml:"vel_body"`                // velocity obtained from gyro-compensated and distance-scaled optical flow raw measurements in body frame(m/s)
	VelNe                 [2]float32 `yaml:"vel_ne"`                  // same as vel_body but in local frame (m/s)
	VelBodyFiltered       [2]float32 `yaml:"vel_body_filtered"`       // filtered velocity obtained from gyro-compensated and distance-scaled optical flow raw measurements in body frame(m/s)
	VelNeFiltered         [2]float32 `yaml:"vel_ne_filtered"`         // filtered same as vel_body_filtered but in local frame (m/s)
	FlowRateUncompensated [2]float32 `yaml:"flow_rate_uncompensated"` // integrated optical flow measurement (rad/s)
	FlowRateCompensated   [2]float32 `yaml:"flow_rate_compensated"`   // integrated optical flow measurement compensated for angular motion (rad/s)
	GyroRate              [3]float32 `yaml:"gyro_rate"`               // gyro measurement synchronized with flow measurements (rad/s)
	GyroBias              [3]float32 `yaml:"gyro_bias"`
	RefGyro               [3]float32 `yaml:"ref_gyro"`
}

// NewVehicleOpticalFlowVel creates a new VehicleOpticalFlowVel with default values.
func NewVehicleOpticalFlowVel() *VehicleOpticalFlowVel {
	self := VehicleOpticalFlowVel{}
	self.SetDefaults()
	return &self
}

func (t *VehicleOpticalFlowVel) Clone() *VehicleOpticalFlowVel {
	c := &VehicleOpticalFlowVel{}
	c.Timestamp = t.Timestamp
	c.TimestampSample = t.TimestampSample
	c.VelBody = t.VelBody
	c.VelNe = t.VelNe
	c.VelBodyFiltered = t.VelBodyFiltered
	c.VelNeFiltered = t.VelNeFiltered
	c.FlowRateUncompensated = t.FlowRateUncompensated
	c.FlowRateCompensated = t.FlowRateCompensated
	c.GyroRate = t.GyroRate
	c.GyroBias = t.GyroBias
	c.RefGyro = t.RefGyro
	return c
}

func (t *VehicleOpticalFlowVel) CloneMsg() types.Message {
	return t.Clone()
}

func (t *VehicleOpticalFlowVel) SetDefaults() {
	t.Timestamp = 0
	t.TimestampSample = 0
	t.VelBody = [2]float32{}
	t.VelNe = [2]float32{}
	t.VelBodyFiltered = [2]float32{}
	t.VelNeFiltered = [2]float32{}
	t.FlowRateUncompensated = [2]float32{}
	t.FlowRateCompensated = [2]float32{}
	t.GyroRate = [3]float32{}
	t.GyroBias = [3]float32{}
	t.RefGyro = [3]float32{}
}

func (t *VehicleOpticalFlowVel) GetTypeSupport() types.MessageTypeSupport {
	return VehicleOpticalFlowVelTypeSupport
}

// VehicleOpticalFlowVelPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type VehicleOpticalFlowVelPublisher struct {
	*rclgo.Publisher
}

// NewVehicleOpticalFlowVelPublisher creates and returns a new publisher for the
// VehicleOpticalFlowVel
func NewVehicleOpticalFlowVelPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*VehicleOpticalFlowVelPublisher, error) {
	pub, err := node.NewPublisher(topic_name, VehicleOpticalFlowVelTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &VehicleOpticalFlowVelPublisher{pub}, nil
}

func (p *VehicleOpticalFlowVelPublisher) Publish(msg *VehicleOpticalFlowVel) error {
	return p.Publisher.Publish(msg)
}

// VehicleOpticalFlowVelSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type VehicleOpticalFlowVelSubscription struct {
	*rclgo.Subscription
}

// VehicleOpticalFlowVelSubscriptionCallback type is used to provide a subscription
// handler function for a VehicleOpticalFlowVelSubscription.
type VehicleOpticalFlowVelSubscriptionCallback func(msg *VehicleOpticalFlowVel, info *rclgo.MessageInfo, err error)

// NewVehicleOpticalFlowVelSubscription creates and returns a new subscription for the
// VehicleOpticalFlowVel
func NewVehicleOpticalFlowVelSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback VehicleOpticalFlowVelSubscriptionCallback) (*VehicleOpticalFlowVelSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg VehicleOpticalFlowVel
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, VehicleOpticalFlowVelTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &VehicleOpticalFlowVelSubscription{sub}, nil
}

func (s *VehicleOpticalFlowVelSubscription) TakeMessage(out *VehicleOpticalFlowVel) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneVehicleOpticalFlowVelSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneVehicleOpticalFlowVelSlice(dst, src []VehicleOpticalFlowVel) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var VehicleOpticalFlowVelTypeSupport types.MessageTypeSupport = _VehicleOpticalFlowVelTypeSupport{}

type _VehicleOpticalFlowVelTypeSupport struct{}

func (t _VehicleOpticalFlowVelTypeSupport) New() types.Message {
	return NewVehicleOpticalFlowVel()
}

func (t _VehicleOpticalFlowVelTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__VehicleOpticalFlowVel
	return (unsafe.Pointer)(C.px4_msgs__msg__VehicleOpticalFlowVel__create())
}

func (t _VehicleOpticalFlowVelTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__VehicleOpticalFlowVel__destroy((*C.px4_msgs__msg__VehicleOpticalFlowVel)(pointer_to_free))
}

func (t _VehicleOpticalFlowVelTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*VehicleOpticalFlowVel)
	mem := (*C.px4_msgs__msg__VehicleOpticalFlowVel)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.timestamp_sample = C.uint64_t(m.TimestampSample)
	cSlice_vel_body := mem.vel_body[:]
	primitives.Float32__Array_to_C(*(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_vel_body)), m.VelBody[:])
	cSlice_vel_ne := mem.vel_ne[:]
	primitives.Float32__Array_to_C(*(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_vel_ne)), m.VelNe[:])
	cSlice_vel_body_filtered := mem.vel_body_filtered[:]
	primitives.Float32__Array_to_C(*(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_vel_body_filtered)), m.VelBodyFiltered[:])
	cSlice_vel_ne_filtered := mem.vel_ne_filtered[:]
	primitives.Float32__Array_to_C(*(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_vel_ne_filtered)), m.VelNeFiltered[:])
	cSlice_flow_rate_uncompensated := mem.flow_rate_uncompensated[:]
	primitives.Float32__Array_to_C(*(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_flow_rate_uncompensated)), m.FlowRateUncompensated[:])
	cSlice_flow_rate_compensated := mem.flow_rate_compensated[:]
	primitives.Float32__Array_to_C(*(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_flow_rate_compensated)), m.FlowRateCompensated[:])
	cSlice_gyro_rate := mem.gyro_rate[:]
	primitives.Float32__Array_to_C(*(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_gyro_rate)), m.GyroRate[:])
	cSlice_gyro_bias := mem.gyro_bias[:]
	primitives.Float32__Array_to_C(*(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_gyro_bias)), m.GyroBias[:])
	cSlice_ref_gyro := mem.ref_gyro[:]
	primitives.Float32__Array_to_C(*(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_ref_gyro)), m.RefGyro[:])
}

func (t _VehicleOpticalFlowVelTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*VehicleOpticalFlowVel)
	mem := (*C.px4_msgs__msg__VehicleOpticalFlowVel)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.TimestampSample = uint64(mem.timestamp_sample)
	cSlice_vel_body := mem.vel_body[:]
	primitives.Float32__Array_to_Go(m.VelBody[:], *(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_vel_body)))
	cSlice_vel_ne := mem.vel_ne[:]
	primitives.Float32__Array_to_Go(m.VelNe[:], *(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_vel_ne)))
	cSlice_vel_body_filtered := mem.vel_body_filtered[:]
	primitives.Float32__Array_to_Go(m.VelBodyFiltered[:], *(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_vel_body_filtered)))
	cSlice_vel_ne_filtered := mem.vel_ne_filtered[:]
	primitives.Float32__Array_to_Go(m.VelNeFiltered[:], *(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_vel_ne_filtered)))
	cSlice_flow_rate_uncompensated := mem.flow_rate_uncompensated[:]
	primitives.Float32__Array_to_Go(m.FlowRateUncompensated[:], *(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_flow_rate_uncompensated)))
	cSlice_flow_rate_compensated := mem.flow_rate_compensated[:]
	primitives.Float32__Array_to_Go(m.FlowRateCompensated[:], *(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_flow_rate_compensated)))
	cSlice_gyro_rate := mem.gyro_rate[:]
	primitives.Float32__Array_to_Go(m.GyroRate[:], *(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_gyro_rate)))
	cSlice_gyro_bias := mem.gyro_bias[:]
	primitives.Float32__Array_to_Go(m.GyroBias[:], *(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_gyro_bias)))
	cSlice_ref_gyro := mem.ref_gyro[:]
	primitives.Float32__Array_to_Go(m.RefGyro[:], *(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_ref_gyro)))
}

func (t _VehicleOpticalFlowVelTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__VehicleOpticalFlowVel())
}

type CVehicleOpticalFlowVel = C.px4_msgs__msg__VehicleOpticalFlowVel
type CVehicleOpticalFlowVel__Sequence = C.px4_msgs__msg__VehicleOpticalFlowVel__Sequence

func VehicleOpticalFlowVel__Sequence_to_Go(goSlice *[]VehicleOpticalFlowVel, cSlice CVehicleOpticalFlowVel__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]VehicleOpticalFlowVel, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		VehicleOpticalFlowVelTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func VehicleOpticalFlowVel__Sequence_to_C(cSlice *CVehicleOpticalFlowVel__Sequence, goSlice []VehicleOpticalFlowVel) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.px4_msgs__msg__VehicleOpticalFlowVel)(C.malloc(C.sizeof_struct_px4_msgs__msg__VehicleOpticalFlowVel * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		VehicleOpticalFlowVelTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func VehicleOpticalFlowVel__Array_to_Go(goSlice []VehicleOpticalFlowVel, cSlice []CVehicleOpticalFlowVel) {
	for i := 0; i < len(cSlice); i++ {
		VehicleOpticalFlowVelTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func VehicleOpticalFlowVel__Array_to_C(cSlice []CVehicleOpticalFlowVel, goSlice []VehicleOpticalFlowVel) {
	for i := 0; i < len(goSlice); i++ {
		VehicleOpticalFlowVelTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
