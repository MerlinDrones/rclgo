// Code generated by rclgo-gen. DO NOT EDIT.

package px4_msgs_msg

import (
	"unsafe"

	"github.com/merlindrones/rclgo/pkg/rclgo"
	"github.com/merlindrones/rclgo/pkg/rclgo/typemap"
	"github.com/merlindrones/rclgo/pkg/rclgo/types"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/fuel_tank_status.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/FuelTankStatus", FuelTankStatusTypeSupport)
	typemap.RegisterMessage("px4_msgs/msg/FuelTankStatus", FuelTankStatusTypeSupport)
}

const (
	FuelTankStatus_MAV_FUEL_TYPE_UNKNOWN uint8 = 0 // fuel type not specified. Fuel levels are normalized (i.e., maximum is 1, and other levels are relative to 1).
	FuelTankStatus_MAV_FUEL_TYPE_LIQUID  uint8 = 1 // represents generic liquid fuels, such as gasoline or diesel. Fuel levels are measured in millilitres (ml), and flow rates in millilitres per second (ml/s).
	FuelTankStatus_MAV_FUEL_TYPE_GAS     uint8 = 2 // represents a gas fuel, such as hydrogen, methane, or propane. Fuel levels are in kilo-Pascal (kPa), and flow rates are in milliliters per second (ml/s).
)

type FuelTankStatus struct {
	Timestamp           uint64  `yaml:"timestamp"`             // time since system start (microseconds)
	MaximumFuelCapacity float32 `yaml:"maximum_fuel_capacity"` // maximum fuel capacity. Must always be provided, either from the driver or a parameter
	ConsumedFuel        float32 `yaml:"consumed_fuel"`         // consumed fuel, NaN if not measured. Should not be inferred from the max fuel capacity
	FuelConsumptionRate float32 `yaml:"fuel_consumption_rate"` // fuel consumption rate, NaN if not measured
	PercentRemaining    uint8   `yaml:"percent_remaining"`     // percentage of remaining fuel, UINT8_MAX if not provided
	RemainingFuel       float32 `yaml:"remaining_fuel"`        // remaining fuel, NaN if not measured. Should not be inferred from the max fuel capacity
	FuelTankId          uint8   `yaml:"fuel_tank_id"`          // identifier for the fuel tank. Must match ID of other messages for same fuel system. 0 by default when only a single tank exists
	FuelType            uint32  `yaml:"fuel_type"`             // type of fuel based on MAV_FUEL_TYPE enum. Set to MAV_FUEL_TYPE_UNKNOWN if unknown or it does not fit the provided types
	Temperature         float32 `yaml:"temperature"`           // fuel temperature in Kelvin, NaN if not measured
}

// NewFuelTankStatus creates a new FuelTankStatus with default values.
func NewFuelTankStatus() *FuelTankStatus {
	self := FuelTankStatus{}
	self.SetDefaults()
	return &self
}

func (t *FuelTankStatus) Clone() *FuelTankStatus {
	c := &FuelTankStatus{}
	c.Timestamp = t.Timestamp
	c.MaximumFuelCapacity = t.MaximumFuelCapacity
	c.ConsumedFuel = t.ConsumedFuel
	c.FuelConsumptionRate = t.FuelConsumptionRate
	c.PercentRemaining = t.PercentRemaining
	c.RemainingFuel = t.RemainingFuel
	c.FuelTankId = t.FuelTankId
	c.FuelType = t.FuelType
	c.Temperature = t.Temperature
	return c
}

func (t *FuelTankStatus) CloneMsg() types.Message {
	return t.Clone()
}

func (t *FuelTankStatus) SetDefaults() {
	t.Timestamp = 0
	t.MaximumFuelCapacity = 0
	t.ConsumedFuel = 0
	t.FuelConsumptionRate = 0
	t.PercentRemaining = 0
	t.RemainingFuel = 0
	t.FuelTankId = 0
	t.FuelType = 0
	t.Temperature = 0
}

func (t *FuelTankStatus) GetTypeSupport() types.MessageTypeSupport {
	return FuelTankStatusTypeSupport
}

// FuelTankStatusPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type FuelTankStatusPublisher struct {
	*rclgo.Publisher
}

// NewFuelTankStatusPublisher creates and returns a new publisher for the
// FuelTankStatus
func NewFuelTankStatusPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*FuelTankStatusPublisher, error) {
	pub, err := node.NewPublisher(topic_name, FuelTankStatusTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &FuelTankStatusPublisher{pub}, nil
}

func (p *FuelTankStatusPublisher) Publish(msg *FuelTankStatus) error {
	return p.Publisher.Publish(msg)
}

// FuelTankStatusSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type FuelTankStatusSubscription struct {
	*rclgo.Subscription
}

// FuelTankStatusSubscriptionCallback type is used to provide a subscription
// handler function for a FuelTankStatusSubscription.
type FuelTankStatusSubscriptionCallback func(msg *FuelTankStatus, info *rclgo.MessageInfo, err error)

// NewFuelTankStatusSubscription creates and returns a new subscription for the
// FuelTankStatus
func NewFuelTankStatusSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback FuelTankStatusSubscriptionCallback) (*FuelTankStatusSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg FuelTankStatus
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, FuelTankStatusTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &FuelTankStatusSubscription{sub}, nil
}

func (s *FuelTankStatusSubscription) TakeMessage(out *FuelTankStatus) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneFuelTankStatusSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneFuelTankStatusSlice(dst, src []FuelTankStatus) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var FuelTankStatusTypeSupport types.MessageTypeSupport = _FuelTankStatusTypeSupport{}

type _FuelTankStatusTypeSupport struct{}

func (t _FuelTankStatusTypeSupport) New() types.Message {
	return NewFuelTankStatus()
}

func (t _FuelTankStatusTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__FuelTankStatus
	return (unsafe.Pointer)(C.px4_msgs__msg__FuelTankStatus__create())
}

func (t _FuelTankStatusTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__FuelTankStatus__destroy((*C.px4_msgs__msg__FuelTankStatus)(pointer_to_free))
}

func (t _FuelTankStatusTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*FuelTankStatus)
	mem := (*C.px4_msgs__msg__FuelTankStatus)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.maximum_fuel_capacity = C.float(m.MaximumFuelCapacity)
	mem.consumed_fuel = C.float(m.ConsumedFuel)
	mem.fuel_consumption_rate = C.float(m.FuelConsumptionRate)
	mem.percent_remaining = C.uint8_t(m.PercentRemaining)
	mem.remaining_fuel = C.float(m.RemainingFuel)
	mem.fuel_tank_id = C.uint8_t(m.FuelTankId)
	mem.fuel_type = C.uint32_t(m.FuelType)
	mem.temperature = C.float(m.Temperature)
}

func (t _FuelTankStatusTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*FuelTankStatus)
	mem := (*C.px4_msgs__msg__FuelTankStatus)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.MaximumFuelCapacity = float32(mem.maximum_fuel_capacity)
	m.ConsumedFuel = float32(mem.consumed_fuel)
	m.FuelConsumptionRate = float32(mem.fuel_consumption_rate)
	m.PercentRemaining = uint8(mem.percent_remaining)
	m.RemainingFuel = float32(mem.remaining_fuel)
	m.FuelTankId = uint8(mem.fuel_tank_id)
	m.FuelType = uint32(mem.fuel_type)
	m.Temperature = float32(mem.temperature)
}

func (t _FuelTankStatusTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__FuelTankStatus())
}

type CFuelTankStatus = C.px4_msgs__msg__FuelTankStatus
type CFuelTankStatus__Sequence = C.px4_msgs__msg__FuelTankStatus__Sequence

func FuelTankStatus__Sequence_to_Go(goSlice *[]FuelTankStatus, cSlice CFuelTankStatus__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]FuelTankStatus, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		FuelTankStatusTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func FuelTankStatus__Sequence_to_C(cSlice *CFuelTankStatus__Sequence, goSlice []FuelTankStatus) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.px4_msgs__msg__FuelTankStatus)(C.malloc(C.sizeof_struct_px4_msgs__msg__FuelTankStatus * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		FuelTankStatusTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func FuelTankStatus__Array_to_Go(goSlice []FuelTankStatus, cSlice []CFuelTankStatus) {
	for i := 0; i < len(cSlice); i++ {
		FuelTankStatusTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func FuelTankStatus__Array_to_C(cSlice []CFuelTankStatus, goSlice []FuelTankStatus) {
	for i := 0; i < len(goSlice); i++ {
		FuelTankStatusTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
