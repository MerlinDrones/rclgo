// Code generated by rclgo-gen. DO NOT EDIT.

package px4_msgs_msg

import (
	"unsafe"

	"github.com/merlindrones/rclgo/pkg/rclgo"
	"github.com/merlindrones/rclgo/pkg/rclgo/typemap"
	"github.com/merlindrones/rclgo/pkg/rclgo/types"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/estimator_event_flags.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/EstimatorEventFlags", EstimatorEventFlagsTypeSupport)
	typemap.RegisterMessage("px4_msgs/msg/EstimatorEventFlags", EstimatorEventFlagsTypeSupport)
}

type EstimatorEventFlags struct {
	Timestamp               uint64 `yaml:"timestamp"`                  // time since system start (microseconds)
	TimestampSample         uint64 `yaml:"timestamp_sample"`           // the timestamp of the raw data (microseconds)
	InformationEventChanges uint32 `yaml:"information_event_changes"`  // number of information event changes. information events
	GpsChecksPassed         bool   `yaml:"gps_checks_passed"`          // 0 - true when gps quality checks are passing passed
	ResetVelToGps           bool   `yaml:"reset_vel_to_gps"`           // 1 - true when the velocity states are reset to the gps measurement
	ResetVelToFlow          bool   `yaml:"reset_vel_to_flow"`          // 2 - true when the velocity states are reset using the optical flow measurement
	ResetVelToVision        bool   `yaml:"reset_vel_to_vision"`        // 3 - true when the velocity states are reset to the vision system measurement
	ResetVelToZero          bool   `yaml:"reset_vel_to_zero"`          // 4 - true when the velocity states are reset to zero
	ResetPosToLastKnown     bool   `yaml:"reset_pos_to_last_known"`    // 5 - true when the position states are reset to the last known position
	ResetPosToGps           bool   `yaml:"reset_pos_to_gps"`           // 6 - true when the position states are reset to the gps measurement
	ResetPosToVision        bool   `yaml:"reset_pos_to_vision"`        // 7 - true when the position states are reset to the vision system measurement
	StartingGpsFusion       bool   `yaml:"starting_gps_fusion"`        // 8 - true when the filter starts using gps measurements to correct the state estimates
	StartingVisionPosFusion bool   `yaml:"starting_vision_pos_fusion"` // 9 - true when the filter starts using vision system position measurements to correct the state estimates
	StartingVisionVelFusion bool   `yaml:"starting_vision_vel_fusion"` // 10 - true when the filter starts using vision system velocity measurements to correct the state estimates
	StartingVisionYawFusion bool   `yaml:"starting_vision_yaw_fusion"` // 11 - true when the filter starts using vision system yaw  measurements to correct the state estimates
	YawAlignedToImuGps      bool   `yaml:"yaw_aligned_to_imu_gps"`     // 12 - true when the filter resets the yaw to an estimate derived from IMU and GPS data
	ResetHgtToBaro          bool   `yaml:"reset_hgt_to_baro"`          // 13 - true when the vertical position state is reset to the baro measurement
	ResetHgtToGps           bool   `yaml:"reset_hgt_to_gps"`           // 14 - true when the vertical position state is reset to the gps measurement
	ResetHgtToRng           bool   `yaml:"reset_hgt_to_rng"`           // 15 - true when the vertical position state is reset to the rng measurement
	ResetHgtToEv            bool   `yaml:"reset_hgt_to_ev"`            // 16 - true when the vertical position state is reset to the ev measurement
}

// NewEstimatorEventFlags creates a new EstimatorEventFlags with default values.
func NewEstimatorEventFlags() *EstimatorEventFlags {
	self := EstimatorEventFlags{}
	self.SetDefaults()
	return &self
}

func (t *EstimatorEventFlags) Clone() *EstimatorEventFlags {
	c := &EstimatorEventFlags{}
	c.Timestamp = t.Timestamp
	c.TimestampSample = t.TimestampSample
	c.InformationEventChanges = t.InformationEventChanges
	c.GpsChecksPassed = t.GpsChecksPassed
	c.ResetVelToGps = t.ResetVelToGps
	c.ResetVelToFlow = t.ResetVelToFlow
	c.ResetVelToVision = t.ResetVelToVision
	c.ResetVelToZero = t.ResetVelToZero
	c.ResetPosToLastKnown = t.ResetPosToLastKnown
	c.ResetPosToGps = t.ResetPosToGps
	c.ResetPosToVision = t.ResetPosToVision
	c.StartingGpsFusion = t.StartingGpsFusion
	c.StartingVisionPosFusion = t.StartingVisionPosFusion
	c.StartingVisionVelFusion = t.StartingVisionVelFusion
	c.StartingVisionYawFusion = t.StartingVisionYawFusion
	c.YawAlignedToImuGps = t.YawAlignedToImuGps
	c.ResetHgtToBaro = t.ResetHgtToBaro
	c.ResetHgtToGps = t.ResetHgtToGps
	c.ResetHgtToRng = t.ResetHgtToRng
	c.ResetHgtToEv = t.ResetHgtToEv
	return c
}

func (t *EstimatorEventFlags) CloneMsg() types.Message {
	return t.Clone()
}

func (t *EstimatorEventFlags) SetDefaults() {
	t.Timestamp = 0
	t.TimestampSample = 0
	t.InformationEventChanges = 0
	t.GpsChecksPassed = false
	t.ResetVelToGps = false
	t.ResetVelToFlow = false
	t.ResetVelToVision = false
	t.ResetVelToZero = false
	t.ResetPosToLastKnown = false
	t.ResetPosToGps = false
	t.ResetPosToVision = false
	t.StartingGpsFusion = false
	t.StartingVisionPosFusion = false
	t.StartingVisionVelFusion = false
	t.StartingVisionYawFusion = false
	t.YawAlignedToImuGps = false
	t.ResetHgtToBaro = false
	t.ResetHgtToGps = false
	t.ResetHgtToRng = false
	t.ResetHgtToEv = false
}

func (t *EstimatorEventFlags) GetTypeSupport() types.MessageTypeSupport {
	return EstimatorEventFlagsTypeSupport
}

// EstimatorEventFlagsPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type EstimatorEventFlagsPublisher struct {
	*rclgo.Publisher
}

// NewEstimatorEventFlagsPublisher creates and returns a new publisher for the
// EstimatorEventFlags
func NewEstimatorEventFlagsPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*EstimatorEventFlagsPublisher, error) {
	pub, err := node.NewPublisher(topic_name, EstimatorEventFlagsTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &EstimatorEventFlagsPublisher{pub}, nil
}

func (p *EstimatorEventFlagsPublisher) Publish(msg *EstimatorEventFlags) error {
	return p.Publisher.Publish(msg)
}

// EstimatorEventFlagsSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type EstimatorEventFlagsSubscription struct {
	*rclgo.Subscription
}

// EstimatorEventFlagsSubscriptionCallback type is used to provide a subscription
// handler function for a EstimatorEventFlagsSubscription.
type EstimatorEventFlagsSubscriptionCallback func(msg *EstimatorEventFlags, info *rclgo.MessageInfo, err error)

// NewEstimatorEventFlagsSubscription creates and returns a new subscription for the
// EstimatorEventFlags
func NewEstimatorEventFlagsSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback EstimatorEventFlagsSubscriptionCallback) (*EstimatorEventFlagsSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg EstimatorEventFlags
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, EstimatorEventFlagsTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &EstimatorEventFlagsSubscription{sub}, nil
}

func (s *EstimatorEventFlagsSubscription) TakeMessage(out *EstimatorEventFlags) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneEstimatorEventFlagsSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneEstimatorEventFlagsSlice(dst, src []EstimatorEventFlags) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var EstimatorEventFlagsTypeSupport types.MessageTypeSupport = _EstimatorEventFlagsTypeSupport{}

type _EstimatorEventFlagsTypeSupport struct{}

func (t _EstimatorEventFlagsTypeSupport) New() types.Message {
	return NewEstimatorEventFlags()
}

func (t _EstimatorEventFlagsTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__EstimatorEventFlags
	return (unsafe.Pointer)(C.px4_msgs__msg__EstimatorEventFlags__create())
}

func (t _EstimatorEventFlagsTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__EstimatorEventFlags__destroy((*C.px4_msgs__msg__EstimatorEventFlags)(pointer_to_free))
}

func (t _EstimatorEventFlagsTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*EstimatorEventFlags)
	mem := (*C.px4_msgs__msg__EstimatorEventFlags)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.timestamp_sample = C.uint64_t(m.TimestampSample)
	mem.information_event_changes = C.uint32_t(m.InformationEventChanges)
	mem.gps_checks_passed = C.bool(m.GpsChecksPassed)
	mem.reset_vel_to_gps = C.bool(m.ResetVelToGps)
	mem.reset_vel_to_flow = C.bool(m.ResetVelToFlow)
	mem.reset_vel_to_vision = C.bool(m.ResetVelToVision)
	mem.reset_vel_to_zero = C.bool(m.ResetVelToZero)
	mem.reset_pos_to_last_known = C.bool(m.ResetPosToLastKnown)
	mem.reset_pos_to_gps = C.bool(m.ResetPosToGps)
	mem.reset_pos_to_vision = C.bool(m.ResetPosToVision)
	mem.starting_gps_fusion = C.bool(m.StartingGpsFusion)
	mem.starting_vision_pos_fusion = C.bool(m.StartingVisionPosFusion)
	mem.starting_vision_vel_fusion = C.bool(m.StartingVisionVelFusion)
	mem.starting_vision_yaw_fusion = C.bool(m.StartingVisionYawFusion)
	mem.yaw_aligned_to_imu_gps = C.bool(m.YawAlignedToImuGps)
	mem.reset_hgt_to_baro = C.bool(m.ResetHgtToBaro)
	mem.reset_hgt_to_gps = C.bool(m.ResetHgtToGps)
	mem.reset_hgt_to_rng = C.bool(m.ResetHgtToRng)
	mem.reset_hgt_to_ev = C.bool(m.ResetHgtToEv)
}

func (t _EstimatorEventFlagsTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*EstimatorEventFlags)
	mem := (*C.px4_msgs__msg__EstimatorEventFlags)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.TimestampSample = uint64(mem.timestamp_sample)
	m.InformationEventChanges = uint32(mem.information_event_changes)
	m.GpsChecksPassed = bool(mem.gps_checks_passed)
	m.ResetVelToGps = bool(mem.reset_vel_to_gps)
	m.ResetVelToFlow = bool(mem.reset_vel_to_flow)
	m.ResetVelToVision = bool(mem.reset_vel_to_vision)
	m.ResetVelToZero = bool(mem.reset_vel_to_zero)
	m.ResetPosToLastKnown = bool(mem.reset_pos_to_last_known)
	m.ResetPosToGps = bool(mem.reset_pos_to_gps)
	m.ResetPosToVision = bool(mem.reset_pos_to_vision)
	m.StartingGpsFusion = bool(mem.starting_gps_fusion)
	m.StartingVisionPosFusion = bool(mem.starting_vision_pos_fusion)
	m.StartingVisionVelFusion = bool(mem.starting_vision_vel_fusion)
	m.StartingVisionYawFusion = bool(mem.starting_vision_yaw_fusion)
	m.YawAlignedToImuGps = bool(mem.yaw_aligned_to_imu_gps)
	m.ResetHgtToBaro = bool(mem.reset_hgt_to_baro)
	m.ResetHgtToGps = bool(mem.reset_hgt_to_gps)
	m.ResetHgtToRng = bool(mem.reset_hgt_to_rng)
	m.ResetHgtToEv = bool(mem.reset_hgt_to_ev)
}

func (t _EstimatorEventFlagsTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__EstimatorEventFlags())
}

type CEstimatorEventFlags = C.px4_msgs__msg__EstimatorEventFlags
type CEstimatorEventFlags__Sequence = C.px4_msgs__msg__EstimatorEventFlags__Sequence

func EstimatorEventFlags__Sequence_to_Go(goSlice *[]EstimatorEventFlags, cSlice CEstimatorEventFlags__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]EstimatorEventFlags, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		EstimatorEventFlagsTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func EstimatorEventFlags__Sequence_to_C(cSlice *CEstimatorEventFlags__Sequence, goSlice []EstimatorEventFlags) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.px4_msgs__msg__EstimatorEventFlags)(C.malloc(C.sizeof_struct_px4_msgs__msg__EstimatorEventFlags * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		EstimatorEventFlagsTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func EstimatorEventFlags__Array_to_Go(goSlice []EstimatorEventFlags, cSlice []CEstimatorEventFlags) {
	for i := 0; i < len(cSlice); i++ {
		EstimatorEventFlagsTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func EstimatorEventFlags__Array_to_C(cSlice []CEstimatorEventFlags, goSlice []EstimatorEventFlags) {
	for i := 0; i < len(goSlice); i++ {
		EstimatorEventFlagsTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
