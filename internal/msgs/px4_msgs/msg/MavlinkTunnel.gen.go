// Code generated by rclgo-gen. DO NOT EDIT.

package px4_msgs_msg

import (
	"unsafe"

	"github.com/merlindrones/rclgo/pkg/rclgo"
	primitives "github.com/merlindrones/rclgo/pkg/rclgo/primitives"
	"github.com/merlindrones/rclgo/pkg/rclgo/typemap"
	"github.com/merlindrones/rclgo/pkg/rclgo/types"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/mavlink_tunnel.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/MavlinkTunnel", MavlinkTunnelTypeSupport)
	typemap.RegisterMessage("px4_msgs/msg/MavlinkTunnel", MavlinkTunnelTypeSupport)
}

const (
	MavlinkTunnel_MAV_TUNNEL_PAYLOAD_TYPE_UNKNOWN           uint8 = 0   // Encoding of payload unknown
	MavlinkTunnel_MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED0 uint8 = 200 // Registered for STorM32 gimbal controller
	MavlinkTunnel_MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED1 uint8 = 201 // Registered for STorM32 gimbal controller
	MavlinkTunnel_MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED2 uint8 = 202 // Registered for STorM32 gimbal controller
	MavlinkTunnel_MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED3 uint8 = 203 // Registered for STorM32 gimbal controller
	MavlinkTunnel_MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED4 uint8 = 204 // Registered for STorM32 gimbal controller
	MavlinkTunnel_MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED5 uint8 = 205 // Registered for STorM32 gimbal controller
	MavlinkTunnel_MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED6 uint8 = 206 // Registered for STorM32 gimbal controller
	MavlinkTunnel_MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED7 uint8 = 207 // Registered for STorM32 gimbal controller
	MavlinkTunnel_MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED8 uint8 = 208 // Registered for STorM32 gimbal controller
	MavlinkTunnel_MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED9 uint8 = 209 // Registered for STorM32 gimbal controller
)

type MavlinkTunnel struct {
	Timestamp       uint64     `yaml:"timestamp"`        // Time since system start (microseconds)
	PayloadType     uint16     `yaml:"payload_type"`     // A code that identifies the content of the payload (0 for unknown, which is the default). If this code is less than 32768, it is a 'registered' payload type and the corresponding code should be added to the MAV_TUNNEL_PAYLOAD_TYPE enum. Software creators can register blocks of types as needed. Codes greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase.
	TargetSystem    uint8      `yaml:"target_system"`    // System ID (can be 0 for broadcast, but this is discouraged)
	TargetComponent uint8      `yaml:"target_component"` // Component ID (can be 0 for broadcast, but this is discouraged)
	PayloadLength   uint8      `yaml:"payload_length"`   // Length of the data transported in payload
	Payload         [128]uint8 `yaml:"payload"`          // Data itself
}

// NewMavlinkTunnel creates a new MavlinkTunnel with default values.
func NewMavlinkTunnel() *MavlinkTunnel {
	self := MavlinkTunnel{}
	self.SetDefaults()
	return &self
}

func (t *MavlinkTunnel) Clone() *MavlinkTunnel {
	c := &MavlinkTunnel{}
	c.Timestamp = t.Timestamp
	c.PayloadType = t.PayloadType
	c.TargetSystem = t.TargetSystem
	c.TargetComponent = t.TargetComponent
	c.PayloadLength = t.PayloadLength
	c.Payload = t.Payload
	return c
}

func (t *MavlinkTunnel) CloneMsg() types.Message {
	return t.Clone()
}

func (t *MavlinkTunnel) SetDefaults() {
	t.Timestamp = 0
	t.PayloadType = 0
	t.TargetSystem = 0
	t.TargetComponent = 0
	t.PayloadLength = 0
	t.Payload = [128]uint8{}
}

func (t *MavlinkTunnel) GetTypeSupport() types.MessageTypeSupport {
	return MavlinkTunnelTypeSupport
}

// MavlinkTunnelPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type MavlinkTunnelPublisher struct {
	*rclgo.Publisher
}

// NewMavlinkTunnelPublisher creates and returns a new publisher for the
// MavlinkTunnel
func NewMavlinkTunnelPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*MavlinkTunnelPublisher, error) {
	pub, err := node.NewPublisher(topic_name, MavlinkTunnelTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &MavlinkTunnelPublisher{pub}, nil
}

func (p *MavlinkTunnelPublisher) Publish(msg *MavlinkTunnel) error {
	return p.Publisher.Publish(msg)
}

// MavlinkTunnelSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type MavlinkTunnelSubscription struct {
	*rclgo.Subscription
}

// MavlinkTunnelSubscriptionCallback type is used to provide a subscription
// handler function for a MavlinkTunnelSubscription.
type MavlinkTunnelSubscriptionCallback func(msg *MavlinkTunnel, info *rclgo.MessageInfo, err error)

// NewMavlinkTunnelSubscription creates and returns a new subscription for the
// MavlinkTunnel
func NewMavlinkTunnelSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback MavlinkTunnelSubscriptionCallback) (*MavlinkTunnelSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg MavlinkTunnel
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, MavlinkTunnelTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &MavlinkTunnelSubscription{sub}, nil
}

func (s *MavlinkTunnelSubscription) TakeMessage(out *MavlinkTunnel) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneMavlinkTunnelSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneMavlinkTunnelSlice(dst, src []MavlinkTunnel) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var MavlinkTunnelTypeSupport types.MessageTypeSupport = _MavlinkTunnelTypeSupport{}

type _MavlinkTunnelTypeSupport struct{}

func (t _MavlinkTunnelTypeSupport) New() types.Message {
	return NewMavlinkTunnel()
}

func (t _MavlinkTunnelTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__MavlinkTunnel
	return (unsafe.Pointer)(C.px4_msgs__msg__MavlinkTunnel__create())
}

func (t _MavlinkTunnelTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__MavlinkTunnel__destroy((*C.px4_msgs__msg__MavlinkTunnel)(pointer_to_free))
}

func (t _MavlinkTunnelTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*MavlinkTunnel)
	mem := (*C.px4_msgs__msg__MavlinkTunnel)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.payload_type = C.uint16_t(m.PayloadType)
	mem.target_system = C.uint8_t(m.TargetSystem)
	mem.target_component = C.uint8_t(m.TargetComponent)
	mem.payload_length = C.uint8_t(m.PayloadLength)
	cSlice_payload := mem.payload[:]
	primitives.Uint8__Array_to_C(*(*[]primitives.CUint8)(unsafe.Pointer(&cSlice_payload)), m.Payload[:])
}

func (t _MavlinkTunnelTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*MavlinkTunnel)
	mem := (*C.px4_msgs__msg__MavlinkTunnel)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.PayloadType = uint16(mem.payload_type)
	m.TargetSystem = uint8(mem.target_system)
	m.TargetComponent = uint8(mem.target_component)
	m.PayloadLength = uint8(mem.payload_length)
	cSlice_payload := mem.payload[:]
	primitives.Uint8__Array_to_Go(m.Payload[:], *(*[]primitives.CUint8)(unsafe.Pointer(&cSlice_payload)))
}

func (t _MavlinkTunnelTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__MavlinkTunnel())
}

type CMavlinkTunnel = C.px4_msgs__msg__MavlinkTunnel
type CMavlinkTunnel__Sequence = C.px4_msgs__msg__MavlinkTunnel__Sequence

func MavlinkTunnel__Sequence_to_Go(goSlice *[]MavlinkTunnel, cSlice CMavlinkTunnel__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]MavlinkTunnel, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		MavlinkTunnelTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func MavlinkTunnel__Sequence_to_C(cSlice *CMavlinkTunnel__Sequence, goSlice []MavlinkTunnel) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.px4_msgs__msg__MavlinkTunnel)(C.malloc(C.sizeof_struct_px4_msgs__msg__MavlinkTunnel * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		MavlinkTunnelTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func MavlinkTunnel__Array_to_Go(goSlice []MavlinkTunnel, cSlice []CMavlinkTunnel) {
	for i := 0; i < len(cSlice); i++ {
		MavlinkTunnelTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func MavlinkTunnel__Array_to_C(cSlice []CMavlinkTunnel, goSlice []MavlinkTunnel) {
	for i := 0; i < len(goSlice); i++ {
		MavlinkTunnelTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
