// Code generated by rclgo-gen. DO NOT EDIT.

package px4_msgs_msg

import (
	"unsafe"

	"github.com/merlindrones/rclgo/pkg/rclgo"
	primitives "github.com/merlindrones/rclgo/pkg/rclgo/primitives"
	"github.com/merlindrones/rclgo/pkg/rclgo/typemap"
	"github.com/merlindrones/rclgo/pkg/rclgo/types"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/px4io_status.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/Px4ioStatus", Px4ioStatusTypeSupport)
	typemap.RegisterMessage("px4_msgs/msg/Px4ioStatus", Px4ioStatusTypeSupport)
}

type Px4ioStatus struct {
	Timestamp                 uint64     `yaml:"timestamp"` // time since system start (microseconds)
	FreeMemoryBytes           uint16     `yaml:"free_memory_bytes"`
	VoltageV                  float32    `yaml:"voltage_v"`       // Servo rail voltage in volts
	RssiV                     float32    `yaml:"rssi_v"`          // RSSI pin voltage in volts
	StatusArmSync             bool       `yaml:"status_arm_sync"` // PX4IO status flags (PX4IO_P_STATUS_FLAGS)
	StatusFailsafe            bool       `yaml:"status_failsafe"`
	StatusFmuInitialized      bool       `yaml:"status_fmu_initialized"`
	StatusFmuOk               bool       `yaml:"status_fmu_ok"`
	StatusInitOk              bool       `yaml:"status_init_ok"`
	StatusOutputsArmed        bool       `yaml:"status_outputs_armed"`
	StatusRawPwm              bool       `yaml:"status_raw_pwm"`
	StatusRcOk                bool       `yaml:"status_rc_ok"`
	StatusRcDsm               bool       `yaml:"status_rc_dsm"`
	StatusRcPpm               bool       `yaml:"status_rc_ppm"`
	StatusRcSbus              bool       `yaml:"status_rc_sbus"`
	StatusRcSt24              bool       `yaml:"status_rc_st24"`
	StatusRcSumd              bool       `yaml:"status_rc_sumd"`
	StatusSafetyButtonEvent   bool       `yaml:"status_safety_button_event"` // px4io safety button was pressed for longer than 1 second
	AlarmPwmError             bool       `yaml:"alarm_pwm_error"`            // PX4IO alarms (PX4IO_P_STATUS_ALARMS)
	AlarmRcLost               bool       `yaml:"alarm_rc_lost"`
	ArmingFailsafeCustom      bool       `yaml:"arming_failsafe_custom"` // PX4IO arming (PX4IO_P_SETUP_ARMING)
	ArmingFmuArmed            bool       `yaml:"arming_fmu_armed"`
	ArmingFmuPrearmed         bool       `yaml:"arming_fmu_prearmed"`
	ArmingForceFailsafe       bool       `yaml:"arming_force_failsafe"`
	ArmingIoArmOk             bool       `yaml:"arming_io_arm_ok"`
	ArmingLockdown            bool       `yaml:"arming_lockdown"`
	ArmingTerminationFailsafe bool       `yaml:"arming_termination_failsafe"`
	Pwm                       [8]uint16  `yaml:"pwm"`
	PwmDisarmed               [8]uint16  `yaml:"pwm_disarmed"`
	PwmFailsafe               [8]uint16  `yaml:"pwm_failsafe"`
	PwmRateHz                 [8]uint16  `yaml:"pwm_rate_hz"`
	RawInputs                 [18]uint16 `yaml:"raw_inputs"`
}

// NewPx4ioStatus creates a new Px4ioStatus with default values.
func NewPx4ioStatus() *Px4ioStatus {
	self := Px4ioStatus{}
	self.SetDefaults()
	return &self
}

func (t *Px4ioStatus) Clone() *Px4ioStatus {
	c := &Px4ioStatus{}
	c.Timestamp = t.Timestamp
	c.FreeMemoryBytes = t.FreeMemoryBytes
	c.VoltageV = t.VoltageV
	c.RssiV = t.RssiV
	c.StatusArmSync = t.StatusArmSync
	c.StatusFailsafe = t.StatusFailsafe
	c.StatusFmuInitialized = t.StatusFmuInitialized
	c.StatusFmuOk = t.StatusFmuOk
	c.StatusInitOk = t.StatusInitOk
	c.StatusOutputsArmed = t.StatusOutputsArmed
	c.StatusRawPwm = t.StatusRawPwm
	c.StatusRcOk = t.StatusRcOk
	c.StatusRcDsm = t.StatusRcDsm
	c.StatusRcPpm = t.StatusRcPpm
	c.StatusRcSbus = t.StatusRcSbus
	c.StatusRcSt24 = t.StatusRcSt24
	c.StatusRcSumd = t.StatusRcSumd
	c.StatusSafetyButtonEvent = t.StatusSafetyButtonEvent
	c.AlarmPwmError = t.AlarmPwmError
	c.AlarmRcLost = t.AlarmRcLost
	c.ArmingFailsafeCustom = t.ArmingFailsafeCustom
	c.ArmingFmuArmed = t.ArmingFmuArmed
	c.ArmingFmuPrearmed = t.ArmingFmuPrearmed
	c.ArmingForceFailsafe = t.ArmingForceFailsafe
	c.ArmingIoArmOk = t.ArmingIoArmOk
	c.ArmingLockdown = t.ArmingLockdown
	c.ArmingTerminationFailsafe = t.ArmingTerminationFailsafe
	c.Pwm = t.Pwm
	c.PwmDisarmed = t.PwmDisarmed
	c.PwmFailsafe = t.PwmFailsafe
	c.PwmRateHz = t.PwmRateHz
	c.RawInputs = t.RawInputs
	return c
}

func (t *Px4ioStatus) CloneMsg() types.Message {
	return t.Clone()
}

func (t *Px4ioStatus) SetDefaults() {
	t.Timestamp = 0
	t.FreeMemoryBytes = 0
	t.VoltageV = 0
	t.RssiV = 0
	t.StatusArmSync = false
	t.StatusFailsafe = false
	t.StatusFmuInitialized = false
	t.StatusFmuOk = false
	t.StatusInitOk = false
	t.StatusOutputsArmed = false
	t.StatusRawPwm = false
	t.StatusRcOk = false
	t.StatusRcDsm = false
	t.StatusRcPpm = false
	t.StatusRcSbus = false
	t.StatusRcSt24 = false
	t.StatusRcSumd = false
	t.StatusSafetyButtonEvent = false
	t.AlarmPwmError = false
	t.AlarmRcLost = false
	t.ArmingFailsafeCustom = false
	t.ArmingFmuArmed = false
	t.ArmingFmuPrearmed = false
	t.ArmingForceFailsafe = false
	t.ArmingIoArmOk = false
	t.ArmingLockdown = false
	t.ArmingTerminationFailsafe = false
	t.Pwm = [8]uint16{}
	t.PwmDisarmed = [8]uint16{}
	t.PwmFailsafe = [8]uint16{}
	t.PwmRateHz = [8]uint16{}
	t.RawInputs = [18]uint16{}
}

func (t *Px4ioStatus) GetTypeSupport() types.MessageTypeSupport {
	return Px4ioStatusTypeSupport
}

// Px4ioStatusPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type Px4ioStatusPublisher struct {
	*rclgo.Publisher
}

// NewPx4ioStatusPublisher creates and returns a new publisher for the
// Px4ioStatus
func NewPx4ioStatusPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*Px4ioStatusPublisher, error) {
	pub, err := node.NewPublisher(topic_name, Px4ioStatusTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &Px4ioStatusPublisher{pub}, nil
}

func (p *Px4ioStatusPublisher) Publish(msg *Px4ioStatus) error {
	return p.Publisher.Publish(msg)
}

// Px4ioStatusSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type Px4ioStatusSubscription struct {
	*rclgo.Subscription
}

// Px4ioStatusSubscriptionCallback type is used to provide a subscription
// handler function for a Px4ioStatusSubscription.
type Px4ioStatusSubscriptionCallback func(msg *Px4ioStatus, info *rclgo.MessageInfo, err error)

// NewPx4ioStatusSubscription creates and returns a new subscription for the
// Px4ioStatus
func NewPx4ioStatusSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback Px4ioStatusSubscriptionCallback) (*Px4ioStatusSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg Px4ioStatus
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, Px4ioStatusTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &Px4ioStatusSubscription{sub}, nil
}

func (s *Px4ioStatusSubscription) TakeMessage(out *Px4ioStatus) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// ClonePx4ioStatusSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func ClonePx4ioStatusSlice(dst, src []Px4ioStatus) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var Px4ioStatusTypeSupport types.MessageTypeSupport = _Px4ioStatusTypeSupport{}

type _Px4ioStatusTypeSupport struct{}

func (t _Px4ioStatusTypeSupport) New() types.Message {
	return NewPx4ioStatus()
}

func (t _Px4ioStatusTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__Px4ioStatus
	return (unsafe.Pointer)(C.px4_msgs__msg__Px4ioStatus__create())
}

func (t _Px4ioStatusTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__Px4ioStatus__destroy((*C.px4_msgs__msg__Px4ioStatus)(pointer_to_free))
}

func (t _Px4ioStatusTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*Px4ioStatus)
	mem := (*C.px4_msgs__msg__Px4ioStatus)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.free_memory_bytes = C.uint16_t(m.FreeMemoryBytes)
	mem.voltage_v = C.float(m.VoltageV)
	mem.rssi_v = C.float(m.RssiV)
	mem.status_arm_sync = C.bool(m.StatusArmSync)
	mem.status_failsafe = C.bool(m.StatusFailsafe)
	mem.status_fmu_initialized = C.bool(m.StatusFmuInitialized)
	mem.status_fmu_ok = C.bool(m.StatusFmuOk)
	mem.status_init_ok = C.bool(m.StatusInitOk)
	mem.status_outputs_armed = C.bool(m.StatusOutputsArmed)
	mem.status_raw_pwm = C.bool(m.StatusRawPwm)
	mem.status_rc_ok = C.bool(m.StatusRcOk)
	mem.status_rc_dsm = C.bool(m.StatusRcDsm)
	mem.status_rc_ppm = C.bool(m.StatusRcPpm)
	mem.status_rc_sbus = C.bool(m.StatusRcSbus)
	mem.status_rc_st24 = C.bool(m.StatusRcSt24)
	mem.status_rc_sumd = C.bool(m.StatusRcSumd)
	mem.status_safety_button_event = C.bool(m.StatusSafetyButtonEvent)
	mem.alarm_pwm_error = C.bool(m.AlarmPwmError)
	mem.alarm_rc_lost = C.bool(m.AlarmRcLost)
	mem.arming_failsafe_custom = C.bool(m.ArmingFailsafeCustom)
	mem.arming_fmu_armed = C.bool(m.ArmingFmuArmed)
	mem.arming_fmu_prearmed = C.bool(m.ArmingFmuPrearmed)
	mem.arming_force_failsafe = C.bool(m.ArmingForceFailsafe)
	mem.arming_io_arm_ok = C.bool(m.ArmingIoArmOk)
	mem.arming_lockdown = C.bool(m.ArmingLockdown)
	mem.arming_termination_failsafe = C.bool(m.ArmingTerminationFailsafe)
	cSlice_pwm := mem.pwm[:]
	primitives.Uint16__Array_to_C(*(*[]primitives.CUint16)(unsafe.Pointer(&cSlice_pwm)), m.Pwm[:])
	cSlice_pwm_disarmed := mem.pwm_disarmed[:]
	primitives.Uint16__Array_to_C(*(*[]primitives.CUint16)(unsafe.Pointer(&cSlice_pwm_disarmed)), m.PwmDisarmed[:])
	cSlice_pwm_failsafe := mem.pwm_failsafe[:]
	primitives.Uint16__Array_to_C(*(*[]primitives.CUint16)(unsafe.Pointer(&cSlice_pwm_failsafe)), m.PwmFailsafe[:])
	cSlice_pwm_rate_hz := mem.pwm_rate_hz[:]
	primitives.Uint16__Array_to_C(*(*[]primitives.CUint16)(unsafe.Pointer(&cSlice_pwm_rate_hz)), m.PwmRateHz[:])
	cSlice_raw_inputs := mem.raw_inputs[:]
	primitives.Uint16__Array_to_C(*(*[]primitives.CUint16)(unsafe.Pointer(&cSlice_raw_inputs)), m.RawInputs[:])
}

func (t _Px4ioStatusTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*Px4ioStatus)
	mem := (*C.px4_msgs__msg__Px4ioStatus)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.FreeMemoryBytes = uint16(mem.free_memory_bytes)
	m.VoltageV = float32(mem.voltage_v)
	m.RssiV = float32(mem.rssi_v)
	m.StatusArmSync = bool(mem.status_arm_sync)
	m.StatusFailsafe = bool(mem.status_failsafe)
	m.StatusFmuInitialized = bool(mem.status_fmu_initialized)
	m.StatusFmuOk = bool(mem.status_fmu_ok)
	m.StatusInitOk = bool(mem.status_init_ok)
	m.StatusOutputsArmed = bool(mem.status_outputs_armed)
	m.StatusRawPwm = bool(mem.status_raw_pwm)
	m.StatusRcOk = bool(mem.status_rc_ok)
	m.StatusRcDsm = bool(mem.status_rc_dsm)
	m.StatusRcPpm = bool(mem.status_rc_ppm)
	m.StatusRcSbus = bool(mem.status_rc_sbus)
	m.StatusRcSt24 = bool(mem.status_rc_st24)
	m.StatusRcSumd = bool(mem.status_rc_sumd)
	m.StatusSafetyButtonEvent = bool(mem.status_safety_button_event)
	m.AlarmPwmError = bool(mem.alarm_pwm_error)
	m.AlarmRcLost = bool(mem.alarm_rc_lost)
	m.ArmingFailsafeCustom = bool(mem.arming_failsafe_custom)
	m.ArmingFmuArmed = bool(mem.arming_fmu_armed)
	m.ArmingFmuPrearmed = bool(mem.arming_fmu_prearmed)
	m.ArmingForceFailsafe = bool(mem.arming_force_failsafe)
	m.ArmingIoArmOk = bool(mem.arming_io_arm_ok)
	m.ArmingLockdown = bool(mem.arming_lockdown)
	m.ArmingTerminationFailsafe = bool(mem.arming_termination_failsafe)
	cSlice_pwm := mem.pwm[:]
	primitives.Uint16__Array_to_Go(m.Pwm[:], *(*[]primitives.CUint16)(unsafe.Pointer(&cSlice_pwm)))
	cSlice_pwm_disarmed := mem.pwm_disarmed[:]
	primitives.Uint16__Array_to_Go(m.PwmDisarmed[:], *(*[]primitives.CUint16)(unsafe.Pointer(&cSlice_pwm_disarmed)))
	cSlice_pwm_failsafe := mem.pwm_failsafe[:]
	primitives.Uint16__Array_to_Go(m.PwmFailsafe[:], *(*[]primitives.CUint16)(unsafe.Pointer(&cSlice_pwm_failsafe)))
	cSlice_pwm_rate_hz := mem.pwm_rate_hz[:]
	primitives.Uint16__Array_to_Go(m.PwmRateHz[:], *(*[]primitives.CUint16)(unsafe.Pointer(&cSlice_pwm_rate_hz)))
	cSlice_raw_inputs := mem.raw_inputs[:]
	primitives.Uint16__Array_to_Go(m.RawInputs[:], *(*[]primitives.CUint16)(unsafe.Pointer(&cSlice_raw_inputs)))
}

func (t _Px4ioStatusTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__Px4ioStatus())
}

type CPx4ioStatus = C.px4_msgs__msg__Px4ioStatus
type CPx4ioStatus__Sequence = C.px4_msgs__msg__Px4ioStatus__Sequence

func Px4ioStatus__Sequence_to_Go(goSlice *[]Px4ioStatus, cSlice CPx4ioStatus__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]Px4ioStatus, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		Px4ioStatusTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func Px4ioStatus__Sequence_to_C(cSlice *CPx4ioStatus__Sequence, goSlice []Px4ioStatus) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.px4_msgs__msg__Px4ioStatus)(C.malloc(C.sizeof_struct_px4_msgs__msg__Px4ioStatus * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		Px4ioStatusTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func Px4ioStatus__Array_to_Go(goSlice []Px4ioStatus, cSlice []CPx4ioStatus) {
	for i := 0; i < len(cSlice); i++ {
		Px4ioStatusTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func Px4ioStatus__Array_to_C(cSlice []CPx4ioStatus, goSlice []Px4ioStatus) {
	for i := 0; i < len(goSlice); i++ {
		Px4ioStatusTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
