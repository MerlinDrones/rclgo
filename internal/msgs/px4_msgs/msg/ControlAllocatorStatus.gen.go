// Code generated by rclgo-gen. DO NOT EDIT.

package px4_msgs_msg

import (
	"unsafe"

	"github.com/merlindrones/rclgo/pkg/rclgo"
	primitives "github.com/merlindrones/rclgo/pkg/rclgo/primitives"
	"github.com/merlindrones/rclgo/pkg/rclgo/typemap"
	"github.com/merlindrones/rclgo/pkg/rclgo/types"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/control_allocator_status.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/ControlAllocatorStatus", ControlAllocatorStatusTypeSupport)
	typemap.RegisterMessage("px4_msgs/msg/ControlAllocatorStatus", ControlAllocatorStatusTypeSupport)
}

const (
	ControlAllocatorStatus_ACTUATOR_SATURATION_OK        int8 = 0  // The actuator is not saturated
	ControlAllocatorStatus_ACTUATOR_SATURATION_UPPER_DYN int8 = 1  // The actuator is saturated (with a value <= the desired value) because it cannot increase its value faster
	ControlAllocatorStatus_ACTUATOR_SATURATION_UPPER     int8 = 2  // The actuator is saturated (with a value <= the desired value) because it has reached its maximum value
	ControlAllocatorStatus_ACTUATOR_SATURATION_LOWER_DYN int8 = -1 // The actuator is saturated (with a value >= the desired value) because it cannot decrease its value faster
	ControlAllocatorStatus_ACTUATOR_SATURATION_LOWER     int8 = -2 // The actuator is saturated (with a value >= the desired value) because it has reached its minimum value
)

type ControlAllocatorStatus struct {
	Timestamp               uint64     `yaml:"timestamp"`                  // time since system start (microseconds)
	TorqueSetpointAchieved  bool       `yaml:"torque_setpoint_achieved"`   // Boolean indicating whether the 3D torque setpoint was correctly allocated to actuators. 0 if not achieved, 1 if achieved.
	UnallocatedTorque       [3]float32 `yaml:"unallocated_torque"`         // Unallocated torque. Equal to 0 if the setpoint was achieved.
	ThrustSetpointAchieved  bool       `yaml:"thrust_setpoint_achieved"`   // Boolean indicating whether the 3D thrust setpoint was correctly allocated to actuators. 0 if not achieved, 1 if achieved.
	UnallocatedThrust       [3]float32 `yaml:"unallocated_thrust"`         // Unallocated thrust. Equal to 0 if the setpoint was achieved.
	ActuatorSaturation      [16]int8   `yaml:"actuator_saturation"`        // Indicates actuator saturation status.
	HandledMotorFailureMask uint16     `yaml:"handled_motor_failure_mask"` // Bitmask of failed motors that were removed from the allocation / effectiveness matrix. Not necessarily identical to the report from FailureDetector
}

// NewControlAllocatorStatus creates a new ControlAllocatorStatus with default values.
func NewControlAllocatorStatus() *ControlAllocatorStatus {
	self := ControlAllocatorStatus{}
	self.SetDefaults()
	return &self
}

func (t *ControlAllocatorStatus) Clone() *ControlAllocatorStatus {
	c := &ControlAllocatorStatus{}
	c.Timestamp = t.Timestamp
	c.TorqueSetpointAchieved = t.TorqueSetpointAchieved
	c.UnallocatedTorque = t.UnallocatedTorque
	c.ThrustSetpointAchieved = t.ThrustSetpointAchieved
	c.UnallocatedThrust = t.UnallocatedThrust
	c.ActuatorSaturation = t.ActuatorSaturation
	c.HandledMotorFailureMask = t.HandledMotorFailureMask
	return c
}

func (t *ControlAllocatorStatus) CloneMsg() types.Message {
	return t.Clone()
}

func (t *ControlAllocatorStatus) SetDefaults() {
	t.Timestamp = 0
	t.TorqueSetpointAchieved = false
	t.UnallocatedTorque = [3]float32{}
	t.ThrustSetpointAchieved = false
	t.UnallocatedThrust = [3]float32{}
	t.ActuatorSaturation = [16]int8{}
	t.HandledMotorFailureMask = 0
}

func (t *ControlAllocatorStatus) GetTypeSupport() types.MessageTypeSupport {
	return ControlAllocatorStatusTypeSupport
}

// ControlAllocatorStatusPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type ControlAllocatorStatusPublisher struct {
	*rclgo.Publisher
}

// NewControlAllocatorStatusPublisher creates and returns a new publisher for the
// ControlAllocatorStatus
func NewControlAllocatorStatusPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*ControlAllocatorStatusPublisher, error) {
	pub, err := node.NewPublisher(topic_name, ControlAllocatorStatusTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &ControlAllocatorStatusPublisher{pub}, nil
}

func (p *ControlAllocatorStatusPublisher) Publish(msg *ControlAllocatorStatus) error {
	return p.Publisher.Publish(msg)
}

// ControlAllocatorStatusSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type ControlAllocatorStatusSubscription struct {
	*rclgo.Subscription
}

// ControlAllocatorStatusSubscriptionCallback type is used to provide a subscription
// handler function for a ControlAllocatorStatusSubscription.
type ControlAllocatorStatusSubscriptionCallback func(msg *ControlAllocatorStatus, info *rclgo.MessageInfo, err error)

// NewControlAllocatorStatusSubscription creates and returns a new subscription for the
// ControlAllocatorStatus
func NewControlAllocatorStatusSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback ControlAllocatorStatusSubscriptionCallback) (*ControlAllocatorStatusSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg ControlAllocatorStatus
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, ControlAllocatorStatusTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &ControlAllocatorStatusSubscription{sub}, nil
}

func (s *ControlAllocatorStatusSubscription) TakeMessage(out *ControlAllocatorStatus) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneControlAllocatorStatusSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneControlAllocatorStatusSlice(dst, src []ControlAllocatorStatus) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var ControlAllocatorStatusTypeSupport types.MessageTypeSupport = _ControlAllocatorStatusTypeSupport{}

type _ControlAllocatorStatusTypeSupport struct{}

func (t _ControlAllocatorStatusTypeSupport) New() types.Message {
	return NewControlAllocatorStatus()
}

func (t _ControlAllocatorStatusTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__ControlAllocatorStatus
	return (unsafe.Pointer)(C.px4_msgs__msg__ControlAllocatorStatus__create())
}

func (t _ControlAllocatorStatusTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__ControlAllocatorStatus__destroy((*C.px4_msgs__msg__ControlAllocatorStatus)(pointer_to_free))
}

func (t _ControlAllocatorStatusTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*ControlAllocatorStatus)
	mem := (*C.px4_msgs__msg__ControlAllocatorStatus)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.torque_setpoint_achieved = C.bool(m.TorqueSetpointAchieved)
	cSlice_unallocated_torque := mem.unallocated_torque[:]
	primitives.Float32__Array_to_C(*(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_unallocated_torque)), m.UnallocatedTorque[:])
	mem.thrust_setpoint_achieved = C.bool(m.ThrustSetpointAchieved)
	cSlice_unallocated_thrust := mem.unallocated_thrust[:]
	primitives.Float32__Array_to_C(*(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_unallocated_thrust)), m.UnallocatedThrust[:])
	cSlice_actuator_saturation := mem.actuator_saturation[:]
	primitives.Int8__Array_to_C(*(*[]primitives.CInt8)(unsafe.Pointer(&cSlice_actuator_saturation)), m.ActuatorSaturation[:])
	mem.handled_motor_failure_mask = C.uint16_t(m.HandledMotorFailureMask)
}

func (t _ControlAllocatorStatusTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*ControlAllocatorStatus)
	mem := (*C.px4_msgs__msg__ControlAllocatorStatus)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.TorqueSetpointAchieved = bool(mem.torque_setpoint_achieved)
	cSlice_unallocated_torque := mem.unallocated_torque[:]
	primitives.Float32__Array_to_Go(m.UnallocatedTorque[:], *(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_unallocated_torque)))
	m.ThrustSetpointAchieved = bool(mem.thrust_setpoint_achieved)
	cSlice_unallocated_thrust := mem.unallocated_thrust[:]
	primitives.Float32__Array_to_Go(m.UnallocatedThrust[:], *(*[]primitives.CFloat32)(unsafe.Pointer(&cSlice_unallocated_thrust)))
	cSlice_actuator_saturation := mem.actuator_saturation[:]
	primitives.Int8__Array_to_Go(m.ActuatorSaturation[:], *(*[]primitives.CInt8)(unsafe.Pointer(&cSlice_actuator_saturation)))
	m.HandledMotorFailureMask = uint16(mem.handled_motor_failure_mask)
}

func (t _ControlAllocatorStatusTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__ControlAllocatorStatus())
}

type CControlAllocatorStatus = C.px4_msgs__msg__ControlAllocatorStatus
type CControlAllocatorStatus__Sequence = C.px4_msgs__msg__ControlAllocatorStatus__Sequence

func ControlAllocatorStatus__Sequence_to_Go(goSlice *[]ControlAllocatorStatus, cSlice CControlAllocatorStatus__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]ControlAllocatorStatus, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		ControlAllocatorStatusTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func ControlAllocatorStatus__Sequence_to_C(cSlice *CControlAllocatorStatus__Sequence, goSlice []ControlAllocatorStatus) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.px4_msgs__msg__ControlAllocatorStatus)(C.malloc(C.sizeof_struct_px4_msgs__msg__ControlAllocatorStatus * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		ControlAllocatorStatusTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func ControlAllocatorStatus__Array_to_Go(goSlice []ControlAllocatorStatus, cSlice []CControlAllocatorStatus) {
	for i := 0; i < len(cSlice); i++ {
		ControlAllocatorStatusTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func ControlAllocatorStatus__Array_to_C(cSlice []CControlAllocatorStatus, goSlice []ControlAllocatorStatus) {
	for i := 0; i < len(goSlice); i++ {
		ControlAllocatorStatusTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
