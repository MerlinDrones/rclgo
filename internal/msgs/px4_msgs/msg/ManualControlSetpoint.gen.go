// Code generated by rclgo-gen. DO NOT EDIT.

package px4_msgs_msg

import (
	"unsafe"

	"github.com/merlindrones/rclgo/pkg/rclgo"
	"github.com/merlindrones/rclgo/pkg/rclgo/typemap"
	"github.com/merlindrones/rclgo/pkg/rclgo/types"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/manual_control_setpoint.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/ManualControlSetpoint", ManualControlSetpointTypeSupport)
	typemap.RegisterMessage("px4_msgs/msg/ManualControlSetpoint", ManualControlSetpointTypeSupport)
}

const (
	ManualControlSetpoint_SOURCE_UNKNOWN   uint8 = 0
	ManualControlSetpoint_SOURCE_RC        uint8 = 1 // radio control (input_rc)
	ManualControlSetpoint_SOURCE_MAVLINK_0 uint8 = 2 // mavlink instance 0
	ManualControlSetpoint_SOURCE_MAVLINK_1 uint8 = 3 // mavlink instance 1
	ManualControlSetpoint_SOURCE_MAVLINK_2 uint8 = 4 // mavlink instance 2
	ManualControlSetpoint_SOURCE_MAVLINK_3 uint8 = 5 // mavlink instance 3
	ManualControlSetpoint_SOURCE_MAVLINK_4 uint8 = 6 // mavlink instance 4
	ManualControlSetpoint_SOURCE_MAVLINK_5 uint8 = 7 // mavlink instance 5
)

type ManualControlSetpoint struct {
	Timestamp       uint64  `yaml:"timestamp"`        // time since system start (microseconds)
	TimestampSample uint64  `yaml:"timestamp_sample"` // the timestamp of the raw data (microseconds)
	Valid           bool    `yaml:"valid"`
	DataSource      uint8   `yaml:"data_source"`
	Roll            float32 `yaml:"roll"`     // move right,   positive roll rotation,  right side down. Stick positions [-1,1]on a common RC mode 1/2/3/4 remote/joystick the stick deflection: -1 is down/left, 1 is up/rightNote: QGC sends throttle/z in range [0,1000] - [0,1]. The MAVLink input conversion [0,1] to [-1,1] is at the moment kept backwards compatible.Positive values are generally used for:
	Pitch           float32 `yaml:"pitch"`    // move forward, negative pitch rotation, nose down
	Yaw             float32 `yaml:"yaw"`      // positive yaw rotation,   clockwise when seen top down
	Throttle        float32 `yaml:"throttle"` // move up,      positive thrust,         -1 is minimum available 0% or -100% +1 is 100% thrust
	Flaps           float32 `yaml:"flaps"`    // position of flaps switch/knob/lever [-1, 1]
	Aux1            float32 `yaml:"aux1"`
	Aux2            float32 `yaml:"aux2"`
	Aux3            float32 `yaml:"aux3"`
	Aux4            float32 `yaml:"aux4"`
	Aux5            float32 `yaml:"aux5"`
	Aux6            float32 `yaml:"aux6"`
	SticksMoving    bool    `yaml:"sticks_moving"`
	Buttons         uint16  `yaml:"buttons"` // From uint16 buttons field of Mavlink manual_control message
}

// NewManualControlSetpoint creates a new ManualControlSetpoint with default values.
func NewManualControlSetpoint() *ManualControlSetpoint {
	self := ManualControlSetpoint{}
	self.SetDefaults()
	return &self
}

func (t *ManualControlSetpoint) Clone() *ManualControlSetpoint {
	c := &ManualControlSetpoint{}
	c.Timestamp = t.Timestamp
	c.TimestampSample = t.TimestampSample
	c.Valid = t.Valid
	c.DataSource = t.DataSource
	c.Roll = t.Roll
	c.Pitch = t.Pitch
	c.Yaw = t.Yaw
	c.Throttle = t.Throttle
	c.Flaps = t.Flaps
	c.Aux1 = t.Aux1
	c.Aux2 = t.Aux2
	c.Aux3 = t.Aux3
	c.Aux4 = t.Aux4
	c.Aux5 = t.Aux5
	c.Aux6 = t.Aux6
	c.SticksMoving = t.SticksMoving
	c.Buttons = t.Buttons
	return c
}

func (t *ManualControlSetpoint) CloneMsg() types.Message {
	return t.Clone()
}

func (t *ManualControlSetpoint) SetDefaults() {
	t.Timestamp = 0
	t.TimestampSample = 0
	t.Valid = false
	t.DataSource = 0
	t.Roll = 0
	t.Pitch = 0
	t.Yaw = 0
	t.Throttle = 0
	t.Flaps = 0
	t.Aux1 = 0
	t.Aux2 = 0
	t.Aux3 = 0
	t.Aux4 = 0
	t.Aux5 = 0
	t.Aux6 = 0
	t.SticksMoving = false
	t.Buttons = 0
}

func (t *ManualControlSetpoint) GetTypeSupport() types.MessageTypeSupport {
	return ManualControlSetpointTypeSupport
}

// ManualControlSetpointPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type ManualControlSetpointPublisher struct {
	*rclgo.Publisher
}

// NewManualControlSetpointPublisher creates and returns a new publisher for the
// ManualControlSetpoint
func NewManualControlSetpointPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*ManualControlSetpointPublisher, error) {
	pub, err := node.NewPublisher(topic_name, ManualControlSetpointTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &ManualControlSetpointPublisher{pub}, nil
}

func (p *ManualControlSetpointPublisher) Publish(msg *ManualControlSetpoint) error {
	return p.Publisher.Publish(msg)
}

// ManualControlSetpointSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type ManualControlSetpointSubscription struct {
	*rclgo.Subscription
}

// ManualControlSetpointSubscriptionCallback type is used to provide a subscription
// handler function for a ManualControlSetpointSubscription.
type ManualControlSetpointSubscriptionCallback func(msg *ManualControlSetpoint, info *rclgo.MessageInfo, err error)

// NewManualControlSetpointSubscription creates and returns a new subscription for the
// ManualControlSetpoint
func NewManualControlSetpointSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback ManualControlSetpointSubscriptionCallback) (*ManualControlSetpointSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg ManualControlSetpoint
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, ManualControlSetpointTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &ManualControlSetpointSubscription{sub}, nil
}

func (s *ManualControlSetpointSubscription) TakeMessage(out *ManualControlSetpoint) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneManualControlSetpointSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneManualControlSetpointSlice(dst, src []ManualControlSetpoint) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var ManualControlSetpointTypeSupport types.MessageTypeSupport = _ManualControlSetpointTypeSupport{}

type _ManualControlSetpointTypeSupport struct{}

func (t _ManualControlSetpointTypeSupport) New() types.Message {
	return NewManualControlSetpoint()
}

func (t _ManualControlSetpointTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__ManualControlSetpoint
	return (unsafe.Pointer)(C.px4_msgs__msg__ManualControlSetpoint__create())
}

func (t _ManualControlSetpointTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__ManualControlSetpoint__destroy((*C.px4_msgs__msg__ManualControlSetpoint)(pointer_to_free))
}

func (t _ManualControlSetpointTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*ManualControlSetpoint)
	mem := (*C.px4_msgs__msg__ManualControlSetpoint)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.timestamp_sample = C.uint64_t(m.TimestampSample)
	mem.valid = C.bool(m.Valid)
	mem.data_source = C.uint8_t(m.DataSource)
	mem.roll = C.float(m.Roll)
	mem.pitch = C.float(m.Pitch)
	mem.yaw = C.float(m.Yaw)
	mem.throttle = C.float(m.Throttle)
	mem.flaps = C.float(m.Flaps)
	mem.aux1 = C.float(m.Aux1)
	mem.aux2 = C.float(m.Aux2)
	mem.aux3 = C.float(m.Aux3)
	mem.aux4 = C.float(m.Aux4)
	mem.aux5 = C.float(m.Aux5)
	mem.aux6 = C.float(m.Aux6)
	mem.sticks_moving = C.bool(m.SticksMoving)
	mem.buttons = C.uint16_t(m.Buttons)
}

func (t _ManualControlSetpointTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*ManualControlSetpoint)
	mem := (*C.px4_msgs__msg__ManualControlSetpoint)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.TimestampSample = uint64(mem.timestamp_sample)
	m.Valid = bool(mem.valid)
	m.DataSource = uint8(mem.data_source)
	m.Roll = float32(mem.roll)
	m.Pitch = float32(mem.pitch)
	m.Yaw = float32(mem.yaw)
	m.Throttle = float32(mem.throttle)
	m.Flaps = float32(mem.flaps)
	m.Aux1 = float32(mem.aux1)
	m.Aux2 = float32(mem.aux2)
	m.Aux3 = float32(mem.aux3)
	m.Aux4 = float32(mem.aux4)
	m.Aux5 = float32(mem.aux5)
	m.Aux6 = float32(mem.aux6)
	m.SticksMoving = bool(mem.sticks_moving)
	m.Buttons = uint16(mem.buttons)
}

func (t _ManualControlSetpointTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__ManualControlSetpoint())
}

type CManualControlSetpoint = C.px4_msgs__msg__ManualControlSetpoint
type CManualControlSetpoint__Sequence = C.px4_msgs__msg__ManualControlSetpoint__Sequence

func ManualControlSetpoint__Sequence_to_Go(goSlice *[]ManualControlSetpoint, cSlice CManualControlSetpoint__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]ManualControlSetpoint, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		ManualControlSetpointTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func ManualControlSetpoint__Sequence_to_C(cSlice *CManualControlSetpoint__Sequence, goSlice []ManualControlSetpoint) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.px4_msgs__msg__ManualControlSetpoint)(C.malloc(C.sizeof_struct_px4_msgs__msg__ManualControlSetpoint * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		ManualControlSetpointTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func ManualControlSetpoint__Array_to_Go(goSlice []ManualControlSetpoint, cSlice []CManualControlSetpoint) {
	for i := 0; i < len(cSlice); i++ {
		ManualControlSetpointTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func ManualControlSetpoint__Array_to_C(cSlice []CManualControlSetpoint, goSlice []ManualControlSetpoint) {
	for i := 0; i < len(goSlice); i++ {
		ManualControlSetpointTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
