// Code generated by rclgo-gen. DO NOT EDIT.

package px4_msgs_msg

import (
	"unsafe"

	"github.com/merlindrones/rclgo/pkg/rclgo"
	"github.com/merlindrones/rclgo/pkg/rclgo/typemap"
	"github.com/merlindrones/rclgo/pkg/rclgo/types"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/mission_result.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/MissionResult", MissionResultTypeSupport)
	typemap.RegisterMessage("px4_msgs/msg/MissionResult", MissionResultTypeSupport)
}

type MissionResult struct {
	Timestamp           uint64 `yaml:"timestamp"`              // time since system start (microseconds)
	MissionId           uint32 `yaml:"mission_id"`             // Id for the mission for which the result was generated
	GeofenceId          uint32 `yaml:"geofence_id"`            // Id for the corresponding geofence for which the result was generated (used for mission feasibility)
	HomePositionCounter uint32 `yaml:"home_position_counter"`  // Counter of the home position for which the result was generated (used for mission feasibility)
	SeqReached          int32  `yaml:"seq_reached"`            // Sequence of the mission item which has been reached, default -1
	SeqCurrent          uint16 `yaml:"seq_current"`            // Sequence of the current mission item
	SeqTotal            uint16 `yaml:"seq_total"`              // Total number of mission items
	Valid               bool   `yaml:"valid"`                  // true if mission is valid
	Warning             bool   `yaml:"warning"`                // true if mission is valid, but has potentially problematic items leading to safety warnings
	Finished            bool   `yaml:"finished"`               // true if mission has been completed
	Failure             bool   `yaml:"failure"`                // true if the mission cannot continue or be completed for some reason
	ItemDoJumpChanged   bool   `yaml:"item_do_jump_changed"`   // true if the number of do jumps remaining has changed
	ItemChangedIndex    uint16 `yaml:"item_changed_index"`     // indicate which item has changed
	ItemDoJumpRemaining uint16 `yaml:"item_do_jump_remaining"` // set to the number of do jumps remaining for that item
	ExecutionMode       uint8  `yaml:"execution_mode"`         // indicates the mode in which the mission is executed
}

// NewMissionResult creates a new MissionResult with default values.
func NewMissionResult() *MissionResult {
	self := MissionResult{}
	self.SetDefaults()
	return &self
}

func (t *MissionResult) Clone() *MissionResult {
	c := &MissionResult{}
	c.Timestamp = t.Timestamp
	c.MissionId = t.MissionId
	c.GeofenceId = t.GeofenceId
	c.HomePositionCounter = t.HomePositionCounter
	c.SeqReached = t.SeqReached
	c.SeqCurrent = t.SeqCurrent
	c.SeqTotal = t.SeqTotal
	c.Valid = t.Valid
	c.Warning = t.Warning
	c.Finished = t.Finished
	c.Failure = t.Failure
	c.ItemDoJumpChanged = t.ItemDoJumpChanged
	c.ItemChangedIndex = t.ItemChangedIndex
	c.ItemDoJumpRemaining = t.ItemDoJumpRemaining
	c.ExecutionMode = t.ExecutionMode
	return c
}

func (t *MissionResult) CloneMsg() types.Message {
	return t.Clone()
}

func (t *MissionResult) SetDefaults() {
	t.Timestamp = 0
	t.MissionId = 0
	t.GeofenceId = 0
	t.HomePositionCounter = 0
	t.SeqReached = 0
	t.SeqCurrent = 0
	t.SeqTotal = 0
	t.Valid = false
	t.Warning = false
	t.Finished = false
	t.Failure = false
	t.ItemDoJumpChanged = false
	t.ItemChangedIndex = 0
	t.ItemDoJumpRemaining = 0
	t.ExecutionMode = 0
}

func (t *MissionResult) GetTypeSupport() types.MessageTypeSupport {
	return MissionResultTypeSupport
}

// MissionResultPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type MissionResultPublisher struct {
	*rclgo.Publisher
}

// NewMissionResultPublisher creates and returns a new publisher for the
// MissionResult
func NewMissionResultPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*MissionResultPublisher, error) {
	pub, err := node.NewPublisher(topic_name, MissionResultTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &MissionResultPublisher{pub}, nil
}

func (p *MissionResultPublisher) Publish(msg *MissionResult) error {
	return p.Publisher.Publish(msg)
}

// MissionResultSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type MissionResultSubscription struct {
	*rclgo.Subscription
}

// MissionResultSubscriptionCallback type is used to provide a subscription
// handler function for a MissionResultSubscription.
type MissionResultSubscriptionCallback func(msg *MissionResult, info *rclgo.MessageInfo, err error)

// NewMissionResultSubscription creates and returns a new subscription for the
// MissionResult
func NewMissionResultSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback MissionResultSubscriptionCallback) (*MissionResultSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg MissionResult
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, MissionResultTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &MissionResultSubscription{sub}, nil
}

func (s *MissionResultSubscription) TakeMessage(out *MissionResult) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneMissionResultSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneMissionResultSlice(dst, src []MissionResult) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var MissionResultTypeSupport types.MessageTypeSupport = _MissionResultTypeSupport{}

type _MissionResultTypeSupport struct{}

func (t _MissionResultTypeSupport) New() types.Message {
	return NewMissionResult()
}

func (t _MissionResultTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__MissionResult
	return (unsafe.Pointer)(C.px4_msgs__msg__MissionResult__create())
}

func (t _MissionResultTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__MissionResult__destroy((*C.px4_msgs__msg__MissionResult)(pointer_to_free))
}

func (t _MissionResultTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*MissionResult)
	mem := (*C.px4_msgs__msg__MissionResult)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.mission_id = C.uint32_t(m.MissionId)
	mem.geofence_id = C.uint32_t(m.GeofenceId)
	mem.home_position_counter = C.uint32_t(m.HomePositionCounter)
	mem.seq_reached = C.int32_t(m.SeqReached)
	mem.seq_current = C.uint16_t(m.SeqCurrent)
	mem.seq_total = C.uint16_t(m.SeqTotal)
	mem.valid = C.bool(m.Valid)
	mem.warning = C.bool(m.Warning)
	mem.finished = C.bool(m.Finished)
	mem.failure = C.bool(m.Failure)
	mem.item_do_jump_changed = C.bool(m.ItemDoJumpChanged)
	mem.item_changed_index = C.uint16_t(m.ItemChangedIndex)
	mem.item_do_jump_remaining = C.uint16_t(m.ItemDoJumpRemaining)
	mem.execution_mode = C.uint8_t(m.ExecutionMode)
}

func (t _MissionResultTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*MissionResult)
	mem := (*C.px4_msgs__msg__MissionResult)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.MissionId = uint32(mem.mission_id)
	m.GeofenceId = uint32(mem.geofence_id)
	m.HomePositionCounter = uint32(mem.home_position_counter)
	m.SeqReached = int32(mem.seq_reached)
	m.SeqCurrent = uint16(mem.seq_current)
	m.SeqTotal = uint16(mem.seq_total)
	m.Valid = bool(mem.valid)
	m.Warning = bool(mem.warning)
	m.Finished = bool(mem.finished)
	m.Failure = bool(mem.failure)
	m.ItemDoJumpChanged = bool(mem.item_do_jump_changed)
	m.ItemChangedIndex = uint16(mem.item_changed_index)
	m.ItemDoJumpRemaining = uint16(mem.item_do_jump_remaining)
	m.ExecutionMode = uint8(mem.execution_mode)
}

func (t _MissionResultTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__MissionResult())
}

type CMissionResult = C.px4_msgs__msg__MissionResult
type CMissionResult__Sequence = C.px4_msgs__msg__MissionResult__Sequence

func MissionResult__Sequence_to_Go(goSlice *[]MissionResult, cSlice CMissionResult__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]MissionResult, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		MissionResultTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func MissionResult__Sequence_to_C(cSlice *CMissionResult__Sequence, goSlice []MissionResult) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.px4_msgs__msg__MissionResult)(C.malloc(C.sizeof_struct_px4_msgs__msg__MissionResult * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		MissionResultTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func MissionResult__Array_to_Go(goSlice []MissionResult, cSlice []CMissionResult) {
	for i := 0; i < len(cSlice); i++ {
		MissionResultTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func MissionResult__Array_to_C(cSlice []CMissionResult, goSlice []MissionResult) {
	for i := 0; i < len(goSlice); i++ {
		MissionResultTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
