// Code generated by rclgo-gen. DO NOT EDIT.

package px4_msgs_msg

import (
	"unsafe"

	"github.com/merlindrones/rclgo/pkg/rclgo"
	"github.com/merlindrones/rclgo/pkg/rclgo/typemap"
	"github.com/merlindrones/rclgo/pkg/rclgo/types"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/cellular_status.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/CellularStatus", CellularStatusTypeSupport)
	typemap.RegisterMessage("px4_msgs/msg/CellularStatus", CellularStatusTypeSupport)
}

const (
	CellularStatus_CELLULAR_STATUS_FLAG_UNKNOWN               uint8 = 0  // State unknown or not reportable
	CellularStatus_CELLULAR_STATUS_FLAG_FAILED                uint8 = 1  // velocity setpoint
	CellularStatus_CELLULAR_STATUS_FLAG_INITIALIZING          uint8 = 2  // Modem is being initialized
	CellularStatus_CELLULAR_STATUS_FLAG_LOCKED                uint8 = 3  // Modem is locked
	CellularStatus_CELLULAR_STATUS_FLAG_DISABLED              uint8 = 4  // Modem is not enabled and is powered down
	CellularStatus_CELLULAR_STATUS_FLAG_DISABLING             uint8 = 5  // Modem is currently transitioning to the CELLULAR_STATUS_FLAG_DISABLED state
	CellularStatus_CELLULAR_STATUS_FLAG_ENABLING              uint8 = 6  // Modem is currently transitioning to the CELLULAR_STATUS_FLAG_ENABLED state
	CellularStatus_CELLULAR_STATUS_FLAG_ENABLED               uint8 = 7  // Modem is enabled and powered on but not registered with a network provider and not available for data connections
	CellularStatus_CELLULAR_STATUS_FLAG_SEARCHING             uint8 = 8  // Modem is searching for a network provider to register
	CellularStatus_CELLULAR_STATUS_FLAG_REGISTERED            uint8 = 9  // Modem is registered with a network provider, and data connections and messaging may be available for use
	CellularStatus_CELLULAR_STATUS_FLAG_DISCONNECTING         uint8 = 10 // Modem is disconnecting and deactivating the last active packet data bearer. This state will not be entered if more than one packet data bearer is active and one of the active bearers is deactivated
	CellularStatus_CELLULAR_STATUS_FLAG_CONNECTING            uint8 = 11 // Modem is activating and connecting the first packet data bearer. Subsequent bearer activations when another bearer is already active do not cause this state to be entered
	CellularStatus_CELLULAR_STATUS_FLAG_CONNECTED             uint8 = 12 // One or more packet data bearers is active and connected
	CellularStatus_CELLULAR_NETWORK_FAILED_REASON_NONE        uint8 = 0  // No error
	CellularStatus_CELLULAR_NETWORK_FAILED_REASON_UNKNOWN     uint8 = 1  // Error state is unknown
	CellularStatus_CELLULAR_NETWORK_FAILED_REASON_SIM_MISSING uint8 = 2  // SIM is required for the modem but missing
	CellularStatus_CELLULAR_NETWORK_FAILED_REASON_SIM_ERROR   uint8 = 3  // SIM is available, but not usable for connection
)

type CellularStatus struct {
	Timestamp     uint64 `yaml:"timestamp"`      // time since system start (microseconds)
	Status        uint16 `yaml:"status"`         // Status bitmap 1: Roaming is active
	FailureReason uint8  `yaml:"failure_reason"` // Failure reason when status in in CELLUAR_STATUS_FAILED
	Type          uint8  `yaml:"type"`           // Cellular network radio type 0: none 1: gsm 2: cdma 3: wcdma 4: lte
	Quality       uint8  `yaml:"quality"`        // Cellular network RSSI/RSRP in dBm, absolute value
	Mcc           uint16 `yaml:"mcc"`            // Mobile country code. If unknown, set to: UINT16_MAX
	Mnc           uint16 `yaml:"mnc"`            // Mobile network code. If unknown, set to: UINT16_MAX
	Lac           uint16 `yaml:"lac"`            // Location area code. If unknown, set to: 0
}

// NewCellularStatus creates a new CellularStatus with default values.
func NewCellularStatus() *CellularStatus {
	self := CellularStatus{}
	self.SetDefaults()
	return &self
}

func (t *CellularStatus) Clone() *CellularStatus {
	c := &CellularStatus{}
	c.Timestamp = t.Timestamp
	c.Status = t.Status
	c.FailureReason = t.FailureReason
	c.Type = t.Type
	c.Quality = t.Quality
	c.Mcc = t.Mcc
	c.Mnc = t.Mnc
	c.Lac = t.Lac
	return c
}

func (t *CellularStatus) CloneMsg() types.Message {
	return t.Clone()
}

func (t *CellularStatus) SetDefaults() {
	t.Timestamp = 0
	t.Status = 0
	t.FailureReason = 0
	t.Type = 0
	t.Quality = 0
	t.Mcc = 0
	t.Mnc = 0
	t.Lac = 0
}

func (t *CellularStatus) GetTypeSupport() types.MessageTypeSupport {
	return CellularStatusTypeSupport
}

// CellularStatusPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type CellularStatusPublisher struct {
	*rclgo.Publisher
}

// NewCellularStatusPublisher creates and returns a new publisher for the
// CellularStatus
func NewCellularStatusPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*CellularStatusPublisher, error) {
	pub, err := node.NewPublisher(topic_name, CellularStatusTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &CellularStatusPublisher{pub}, nil
}

func (p *CellularStatusPublisher) Publish(msg *CellularStatus) error {
	return p.Publisher.Publish(msg)
}

// CellularStatusSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type CellularStatusSubscription struct {
	*rclgo.Subscription
}

// CellularStatusSubscriptionCallback type is used to provide a subscription
// handler function for a CellularStatusSubscription.
type CellularStatusSubscriptionCallback func(msg *CellularStatus, info *rclgo.MessageInfo, err error)

// NewCellularStatusSubscription creates and returns a new subscription for the
// CellularStatus
func NewCellularStatusSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback CellularStatusSubscriptionCallback) (*CellularStatusSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg CellularStatus
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, CellularStatusTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &CellularStatusSubscription{sub}, nil
}

func (s *CellularStatusSubscription) TakeMessage(out *CellularStatus) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneCellularStatusSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneCellularStatusSlice(dst, src []CellularStatus) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var CellularStatusTypeSupport types.MessageTypeSupport = _CellularStatusTypeSupport{}

type _CellularStatusTypeSupport struct{}

func (t _CellularStatusTypeSupport) New() types.Message {
	return NewCellularStatus()
}

func (t _CellularStatusTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__CellularStatus
	return (unsafe.Pointer)(C.px4_msgs__msg__CellularStatus__create())
}

func (t _CellularStatusTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__CellularStatus__destroy((*C.px4_msgs__msg__CellularStatus)(pointer_to_free))
}

func (t _CellularStatusTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*CellularStatus)
	mem := (*C.px4_msgs__msg__CellularStatus)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.status = C.uint16_t(m.Status)
	mem.failure_reason = C.uint8_t(m.FailureReason)
	mem._type = C.uint8_t(m.Type)
	mem.quality = C.uint8_t(m.Quality)
	mem.mcc = C.uint16_t(m.Mcc)
	mem.mnc = C.uint16_t(m.Mnc)
	mem.lac = C.uint16_t(m.Lac)
}

func (t _CellularStatusTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*CellularStatus)
	mem := (*C.px4_msgs__msg__CellularStatus)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.Status = uint16(mem.status)
	m.FailureReason = uint8(mem.failure_reason)
	m.Type = uint8(mem._type)
	m.Quality = uint8(mem.quality)
	m.Mcc = uint16(mem.mcc)
	m.Mnc = uint16(mem.mnc)
	m.Lac = uint16(mem.lac)
}

func (t _CellularStatusTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__CellularStatus())
}

type CCellularStatus = C.px4_msgs__msg__CellularStatus
type CCellularStatus__Sequence = C.px4_msgs__msg__CellularStatus__Sequence

func CellularStatus__Sequence_to_Go(goSlice *[]CellularStatus, cSlice CCellularStatus__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]CellularStatus, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		CellularStatusTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func CellularStatus__Sequence_to_C(cSlice *CCellularStatus__Sequence, goSlice []CellularStatus) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.px4_msgs__msg__CellularStatus)(C.malloc(C.sizeof_struct_px4_msgs__msg__CellularStatus * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		CellularStatusTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func CellularStatus__Array_to_Go(goSlice []CellularStatus, cSlice []CCellularStatus) {
	for i := 0; i < len(cSlice); i++ {
		CellularStatusTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func CellularStatus__Array_to_C(cSlice []CCellularStatus, goSlice []CellularStatus) {
	for i := 0; i < len(goSlice); i++ {
		CellularStatusTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
