// Code generated by rclgo-gen. DO NOT EDIT.

package px4_msgs_msg

import (
	"unsafe"

	"github.com/merlindrones/rclgo/pkg/rclgo"
	"github.com/merlindrones/rclgo/pkg/rclgo/typemap"
	"github.com/merlindrones/rclgo/pkg/rclgo/types"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/failure_detector_status.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/FailureDetectorStatus", FailureDetectorStatusTypeSupport)
	typemap.RegisterMessage("px4_msgs/msg/FailureDetectorStatus", FailureDetectorStatusTypeSupport)
}

type FailureDetectorStatus struct {
	Timestamp            uint64  `yaml:"timestamp"` // time since system start (microseconds)
	FdRoll               bool    `yaml:"fd_roll"`   // FailureDetector status
	FdPitch              bool    `yaml:"fd_pitch"`
	FdAlt                bool    `yaml:"fd_alt"`
	FdExt                bool    `yaml:"fd_ext"`
	FdArmEscs            bool    `yaml:"fd_arm_escs"`
	FdBattery            bool    `yaml:"fd_battery"`
	FdImbalancedProp     bool    `yaml:"fd_imbalanced_prop"`
	FdMotor              bool    `yaml:"fd_motor"`
	ImbalancedPropMetric float32 `yaml:"imbalanced_prop_metric"` // Metric of the imbalanced propeller check (low-passed)
	MotorFailureMask     uint16  `yaml:"motor_failure_mask"`     // Bit-mask with motor indices, indicating critical motor failures
}

// NewFailureDetectorStatus creates a new FailureDetectorStatus with default values.
func NewFailureDetectorStatus() *FailureDetectorStatus {
	self := FailureDetectorStatus{}
	self.SetDefaults()
	return &self
}

func (t *FailureDetectorStatus) Clone() *FailureDetectorStatus {
	c := &FailureDetectorStatus{}
	c.Timestamp = t.Timestamp
	c.FdRoll = t.FdRoll
	c.FdPitch = t.FdPitch
	c.FdAlt = t.FdAlt
	c.FdExt = t.FdExt
	c.FdArmEscs = t.FdArmEscs
	c.FdBattery = t.FdBattery
	c.FdImbalancedProp = t.FdImbalancedProp
	c.FdMotor = t.FdMotor
	c.ImbalancedPropMetric = t.ImbalancedPropMetric
	c.MotorFailureMask = t.MotorFailureMask
	return c
}

func (t *FailureDetectorStatus) CloneMsg() types.Message {
	return t.Clone()
}

func (t *FailureDetectorStatus) SetDefaults() {
	t.Timestamp = 0
	t.FdRoll = false
	t.FdPitch = false
	t.FdAlt = false
	t.FdExt = false
	t.FdArmEscs = false
	t.FdBattery = false
	t.FdImbalancedProp = false
	t.FdMotor = false
	t.ImbalancedPropMetric = 0
	t.MotorFailureMask = 0
}

func (t *FailureDetectorStatus) GetTypeSupport() types.MessageTypeSupport {
	return FailureDetectorStatusTypeSupport
}

// FailureDetectorStatusPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type FailureDetectorStatusPublisher struct {
	*rclgo.Publisher
}

// NewFailureDetectorStatusPublisher creates and returns a new publisher for the
// FailureDetectorStatus
func NewFailureDetectorStatusPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*FailureDetectorStatusPublisher, error) {
	pub, err := node.NewPublisher(topic_name, FailureDetectorStatusTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &FailureDetectorStatusPublisher{pub}, nil
}

func (p *FailureDetectorStatusPublisher) Publish(msg *FailureDetectorStatus) error {
	return p.Publisher.Publish(msg)
}

// FailureDetectorStatusSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type FailureDetectorStatusSubscription struct {
	*rclgo.Subscription
}

// FailureDetectorStatusSubscriptionCallback type is used to provide a subscription
// handler function for a FailureDetectorStatusSubscription.
type FailureDetectorStatusSubscriptionCallback func(msg *FailureDetectorStatus, info *rclgo.MessageInfo, err error)

// NewFailureDetectorStatusSubscription creates and returns a new subscription for the
// FailureDetectorStatus
func NewFailureDetectorStatusSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback FailureDetectorStatusSubscriptionCallback) (*FailureDetectorStatusSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg FailureDetectorStatus
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, FailureDetectorStatusTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &FailureDetectorStatusSubscription{sub}, nil
}

func (s *FailureDetectorStatusSubscription) TakeMessage(out *FailureDetectorStatus) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneFailureDetectorStatusSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneFailureDetectorStatusSlice(dst, src []FailureDetectorStatus) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var FailureDetectorStatusTypeSupport types.MessageTypeSupport = _FailureDetectorStatusTypeSupport{}

type _FailureDetectorStatusTypeSupport struct{}

func (t _FailureDetectorStatusTypeSupport) New() types.Message {
	return NewFailureDetectorStatus()
}

func (t _FailureDetectorStatusTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__FailureDetectorStatus
	return (unsafe.Pointer)(C.px4_msgs__msg__FailureDetectorStatus__create())
}

func (t _FailureDetectorStatusTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__FailureDetectorStatus__destroy((*C.px4_msgs__msg__FailureDetectorStatus)(pointer_to_free))
}

func (t _FailureDetectorStatusTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*FailureDetectorStatus)
	mem := (*C.px4_msgs__msg__FailureDetectorStatus)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.fd_roll = C.bool(m.FdRoll)
	mem.fd_pitch = C.bool(m.FdPitch)
	mem.fd_alt = C.bool(m.FdAlt)
	mem.fd_ext = C.bool(m.FdExt)
	mem.fd_arm_escs = C.bool(m.FdArmEscs)
	mem.fd_battery = C.bool(m.FdBattery)
	mem.fd_imbalanced_prop = C.bool(m.FdImbalancedProp)
	mem.fd_motor = C.bool(m.FdMotor)
	mem.imbalanced_prop_metric = C.float(m.ImbalancedPropMetric)
	mem.motor_failure_mask = C.uint16_t(m.MotorFailureMask)
}

func (t _FailureDetectorStatusTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*FailureDetectorStatus)
	mem := (*C.px4_msgs__msg__FailureDetectorStatus)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.FdRoll = bool(mem.fd_roll)
	m.FdPitch = bool(mem.fd_pitch)
	m.FdAlt = bool(mem.fd_alt)
	m.FdExt = bool(mem.fd_ext)
	m.FdArmEscs = bool(mem.fd_arm_escs)
	m.FdBattery = bool(mem.fd_battery)
	m.FdImbalancedProp = bool(mem.fd_imbalanced_prop)
	m.FdMotor = bool(mem.fd_motor)
	m.ImbalancedPropMetric = float32(mem.imbalanced_prop_metric)
	m.MotorFailureMask = uint16(mem.motor_failure_mask)
}

func (t _FailureDetectorStatusTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__FailureDetectorStatus())
}

type CFailureDetectorStatus = C.px4_msgs__msg__FailureDetectorStatus
type CFailureDetectorStatus__Sequence = C.px4_msgs__msg__FailureDetectorStatus__Sequence

func FailureDetectorStatus__Sequence_to_Go(goSlice *[]FailureDetectorStatus, cSlice CFailureDetectorStatus__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]FailureDetectorStatus, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		FailureDetectorStatusTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func FailureDetectorStatus__Sequence_to_C(cSlice *CFailureDetectorStatus__Sequence, goSlice []FailureDetectorStatus) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.px4_msgs__msg__FailureDetectorStatus)(C.malloc(C.sizeof_struct_px4_msgs__msg__FailureDetectorStatus * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		FailureDetectorStatusTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func FailureDetectorStatus__Array_to_Go(goSlice []FailureDetectorStatus, cSlice []CFailureDetectorStatus) {
	for i := 0; i < len(cSlice); i++ {
		FailureDetectorStatusTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func FailureDetectorStatus__Array_to_C(cSlice []CFailureDetectorStatus, goSlice []FailureDetectorStatus) {
	for i := 0; i < len(goSlice); i++ {
		FailureDetectorStatusTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
