// Code generated by rclgo-gen. DO NOT EDIT.

package px4_msgs_msg

import (
	"unsafe"

	"github.com/merlindrones/rclgo/pkg/rclgo"
	"github.com/merlindrones/rclgo/pkg/rclgo/typemap"
	"github.com/merlindrones/rclgo/pkg/rclgo/types"
)

/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <px4_msgs/msg/npfg_status.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("px4_msgs/NpfgStatus", NpfgStatusTypeSupport)
	typemap.RegisterMessage("px4_msgs/msg/NpfgStatus", NpfgStatusTypeSupport)
}

type NpfgStatus struct {
	Timestamp          uint64  `yaml:"timestamp"`             // time since system start (microseconds)
	WindEstValid       uint8   `yaml:"wind_est_valid"`        // (boolean) true = wind estimate is valid and/or being used by controller (also indicates if wind est usage is disabled despite being valid)
	LatAccel           float32 `yaml:"lat_accel"`             // resultant lateral acceleration reference [m/s^2]
	LatAccelFf         float32 `yaml:"lat_accel_ff"`          // lateral acceleration demand only for maintaining curvature [m/s^2]
	BearingFeas        float32 `yaml:"bearing_feas"`          // bearing feasibility [0,1]
	BearingFeasOnTrack float32 `yaml:"bearing_feas_on_track"` // on-track bearing feasibility [0,1]
	SignedTrackError   float32 `yaml:"signed_track_error"`    // signed track error [m]
	TrackErrorBound    float32 `yaml:"track_error_bound"`     // track error bound [m]
	AirspeedRef        float32 `yaml:"airspeed_ref"`          // (true) airspeed reference [m/s]
	Bearing            float32 `yaml:"bearing"`               // bearing angle [rad]
	HeadingRef         float32 `yaml:"heading_ref"`           // heading angle reference [rad]
	MinGroundSpeedRef  float32 `yaml:"min_ground_speed_ref"`  // minimum forward ground speed reference [m/s]
	AdaptedPeriod      float32 `yaml:"adapted_period"`        // adapted period (if auto-tuning enabled) [s]
	PGain              float32 `yaml:"p_gain"`                // controller proportional gain [rad/s]
	TimeConst          float32 `yaml:"time_const"`            // controller time constant [s]
	CanRunFactor       float32 `yaml:"can_run_factor"`        // estimate of certainty of the correct functionality of the npfg roll setpoint in [0, 1]
}

// NewNpfgStatus creates a new NpfgStatus with default values.
func NewNpfgStatus() *NpfgStatus {
	self := NpfgStatus{}
	self.SetDefaults()
	return &self
}

func (t *NpfgStatus) Clone() *NpfgStatus {
	c := &NpfgStatus{}
	c.Timestamp = t.Timestamp
	c.WindEstValid = t.WindEstValid
	c.LatAccel = t.LatAccel
	c.LatAccelFf = t.LatAccelFf
	c.BearingFeas = t.BearingFeas
	c.BearingFeasOnTrack = t.BearingFeasOnTrack
	c.SignedTrackError = t.SignedTrackError
	c.TrackErrorBound = t.TrackErrorBound
	c.AirspeedRef = t.AirspeedRef
	c.Bearing = t.Bearing
	c.HeadingRef = t.HeadingRef
	c.MinGroundSpeedRef = t.MinGroundSpeedRef
	c.AdaptedPeriod = t.AdaptedPeriod
	c.PGain = t.PGain
	c.TimeConst = t.TimeConst
	c.CanRunFactor = t.CanRunFactor
	return c
}

func (t *NpfgStatus) CloneMsg() types.Message {
	return t.Clone()
}

func (t *NpfgStatus) SetDefaults() {
	t.Timestamp = 0
	t.WindEstValid = 0
	t.LatAccel = 0
	t.LatAccelFf = 0
	t.BearingFeas = 0
	t.BearingFeasOnTrack = 0
	t.SignedTrackError = 0
	t.TrackErrorBound = 0
	t.AirspeedRef = 0
	t.Bearing = 0
	t.HeadingRef = 0
	t.MinGroundSpeedRef = 0
	t.AdaptedPeriod = 0
	t.PGain = 0
	t.TimeConst = 0
	t.CanRunFactor = 0
}

func (t *NpfgStatus) GetTypeSupport() types.MessageTypeSupport {
	return NpfgStatusTypeSupport
}

// NpfgStatusPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type NpfgStatusPublisher struct {
	*rclgo.Publisher
}

// NewNpfgStatusPublisher creates and returns a new publisher for the
// NpfgStatus
func NewNpfgStatusPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*NpfgStatusPublisher, error) {
	pub, err := node.NewPublisher(topic_name, NpfgStatusTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &NpfgStatusPublisher{pub}, nil
}

func (p *NpfgStatusPublisher) Publish(msg *NpfgStatus) error {
	return p.Publisher.Publish(msg)
}

// NpfgStatusSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type NpfgStatusSubscription struct {
	*rclgo.Subscription
}

// NpfgStatusSubscriptionCallback type is used to provide a subscription
// handler function for a NpfgStatusSubscription.
type NpfgStatusSubscriptionCallback func(msg *NpfgStatus, info *rclgo.MessageInfo, err error)

// NewNpfgStatusSubscription creates and returns a new subscription for the
// NpfgStatus
func NewNpfgStatusSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback NpfgStatusSubscriptionCallback) (*NpfgStatusSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg NpfgStatus
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, NpfgStatusTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &NpfgStatusSubscription{sub}, nil
}

func (s *NpfgStatusSubscription) TakeMessage(out *NpfgStatus) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneNpfgStatusSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneNpfgStatusSlice(dst, src []NpfgStatus) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var NpfgStatusTypeSupport types.MessageTypeSupport = _NpfgStatusTypeSupport{}

type _NpfgStatusTypeSupport struct{}

func (t _NpfgStatusTypeSupport) New() types.Message {
	return NewNpfgStatus()
}

func (t _NpfgStatusTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__NpfgStatus
	return (unsafe.Pointer)(C.px4_msgs__msg__NpfgStatus__create())
}

func (t _NpfgStatusTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__NpfgStatus__destroy((*C.px4_msgs__msg__NpfgStatus)(pointer_to_free))
}

func (t _NpfgStatusTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*NpfgStatus)
	mem := (*C.px4_msgs__msg__NpfgStatus)(dst)
	mem.timestamp = C.uint64_t(m.Timestamp)
	mem.wind_est_valid = C.uint8_t(m.WindEstValid)
	mem.lat_accel = C.float(m.LatAccel)
	mem.lat_accel_ff = C.float(m.LatAccelFf)
	mem.bearing_feas = C.float(m.BearingFeas)
	mem.bearing_feas_on_track = C.float(m.BearingFeasOnTrack)
	mem.signed_track_error = C.float(m.SignedTrackError)
	mem.track_error_bound = C.float(m.TrackErrorBound)
	mem.airspeed_ref = C.float(m.AirspeedRef)
	mem.bearing = C.float(m.Bearing)
	mem.heading_ref = C.float(m.HeadingRef)
	mem.min_ground_speed_ref = C.float(m.MinGroundSpeedRef)
	mem.adapted_period = C.float(m.AdaptedPeriod)
	mem.p_gain = C.float(m.PGain)
	mem.time_const = C.float(m.TimeConst)
	mem.can_run_factor = C.float(m.CanRunFactor)
}

func (t _NpfgStatusTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*NpfgStatus)
	mem := (*C.px4_msgs__msg__NpfgStatus)(ros2_message_buffer)
	m.Timestamp = uint64(mem.timestamp)
	m.WindEstValid = uint8(mem.wind_est_valid)
	m.LatAccel = float32(mem.lat_accel)
	m.LatAccelFf = float32(mem.lat_accel_ff)
	m.BearingFeas = float32(mem.bearing_feas)
	m.BearingFeasOnTrack = float32(mem.bearing_feas_on_track)
	m.SignedTrackError = float32(mem.signed_track_error)
	m.TrackErrorBound = float32(mem.track_error_bound)
	m.AirspeedRef = float32(mem.airspeed_ref)
	m.Bearing = float32(mem.bearing)
	m.HeadingRef = float32(mem.heading_ref)
	m.MinGroundSpeedRef = float32(mem.min_ground_speed_ref)
	m.AdaptedPeriod = float32(mem.adapted_period)
	m.PGain = float32(mem.p_gain)
	m.TimeConst = float32(mem.time_const)
	m.CanRunFactor = float32(mem.can_run_factor)
}

func (t _NpfgStatusTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__NpfgStatus())
}

type CNpfgStatus = C.px4_msgs__msg__NpfgStatus
type CNpfgStatus__Sequence = C.px4_msgs__msg__NpfgStatus__Sequence

func NpfgStatus__Sequence_to_Go(goSlice *[]NpfgStatus, cSlice CNpfgStatus__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]NpfgStatus, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		NpfgStatusTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func NpfgStatus__Sequence_to_C(cSlice *CNpfgStatus__Sequence, goSlice []NpfgStatus) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.px4_msgs__msg__NpfgStatus)(C.malloc(C.sizeof_struct_px4_msgs__msg__NpfgStatus * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		NpfgStatusTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func NpfgStatus__Array_to_Go(goSlice []NpfgStatus, cSlice []CNpfgStatus) {
	for i := 0; i < len(cSlice); i++ {
		NpfgStatusTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func NpfgStatus__Array_to_C(cSlice []CNpfgStatus, goSlice []NpfgStatus) {
	for i := 0; i < len(goSlice); i++ {
		NpfgStatusTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
